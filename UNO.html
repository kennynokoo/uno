<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO ÂÑ™ÂåñÁâà</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Nunito Sans', 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents zoom on double tap, good for mobile games */
            background-color: #F0F2F5; /* Slightly lighter background */
            color: #333;
            overscroll-behavior: none; /* Prevents pull-to-refresh or overscroll navigation */
        }
        .action-icon { width: 60%; height: 60%; fill: white; }
        .action-icon.text-black { fill: #222; }

        .card {
            width: 85px; height: 130px; border-radius: 12px;
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
            font-weight: bold; margin: 6px; cursor: pointer;
            box-shadow: 0 5px 10px rgba(0,0,0,0.12); /* Slightly softer shadow */
            transition: transform 0.25s cubic-bezier(0.25, 0.1, 0.25, 1.2), box-shadow 0.25s ease; /* Smoother bezier for transform */
            border: 1px solid rgba(0,0,0,0.08);
            position: relative; padding: 8px;
            background-clip: padding-box; /* Ensures background doesn't go under border */
        }
        .card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 8px 16px rgba(0,0,0,0.18);
        }
        .card .value-center { font-size: 48px; font-weight: 900; line-height: 1; display: flex; align-items: center; justify-content: center; flex-grow: 1; }
        .card .corner-value { position: absolute; font-size: 16px; font-weight: 700; line-height: 1; }
        .card .top-left { top: 8px; left: 8px; }
        .card .bottom-right { bottom: 8px; right: 8px; transform: rotate(180deg); }

        .card-back {
            background: linear-gradient(135deg, #2D3748 0%, #4A5568 100%); /* Gradient for card back */
            border: 3px solid #1A202C; color: white;
            display: flex; justify-content: center; align-items: center;
        }
        .card-back-text {
            font-family: 'Paytone One', 'Arial Black', sans-serif; font-size: 36px; font-weight: bold; color: #FFD700;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 2px 2px 3px rgba(0,0,0,0.6);
            transform: rotate(-10deg);
        }

        /* Card Colors with slight gradient for depth */
        .card-red { background: linear-gradient(135deg, #FF5252, #E53E3E); color: white; }
        .card-yellow { background: linear-gradient(135deg, #FFD600, #FBC02D); color: #333; }
        .card-green { background: linear-gradient(135deg, #69F0AE, #4CAF50); color: white; }
        .card-blue { background: linear-gradient(135deg, #448AFF, #2962FF); color: white; }
        .card-black { background: linear-gradient(135deg, #263238, #1C1C1E); color: white; }


        .wild-center-icon {
            width: 70%; height: 70%; border-radius: 50%;
            background: conic-gradient(from 90deg, red, yellow, lime, aqua, blue, magenta, red);
            display:flex; align-items:center; justify-content:center;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        .wild-center-icon .value-center { font-size: 28px; color: white; text-shadow: 1px 1px 2px black;}

        #game-board { background-color: #FFFFFF; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }

        #opponents-area-container {
            display: flex; flex-wrap: wrap; justify-content: center;
            min-height: 140px; padding: 10px; border-radius: 8px; width: 100%; margin-bottom: 1.5rem;
        }
        #opponents-area-container.one-opponent { justify-content: center; }
        #opponents-area-container.two-opponents { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 1.5rem; max-width: 700px; margin-left: auto; margin-right: auto; }
        #opponents-area-container.three-opponents { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 1rem; }

        .opponent-area {
            padding: 12px; border-radius: 12px; background-color: #F8F9FA; /* Lighter opponent area */
            box-shadow: 0 2px 8px rgba(0,0,0,0.06); border: 1px solid #DEE2E6;
            transition: border-color 0.3s, background-color 0.3s, box-shadow 0.3s;
            min-width: 180px; width: auto; height: 220px; /* Fixed height */
            display: flex; flex-direction: column; align-items: center; overflow: hidden;
        }
        .opponent-area.active-turn { border-color: #007AFF; background-color: #EBF4FF; box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.3), 0 4px 12px rgba(0, 122, 255, 0.2); }
        .opponent-area h3 { flex-shrink: 0; text-align: center; width: 100%; }

        #player-area.active-human-player-area { border: 2px solid #007AFF; box-shadow: 0 0 15px rgba(0, 122, 255, 0.5), 0 0 0 3px rgba(0, 122, 255, 0.2); background-color: #EBF4FF; }
        .player-hand-container { display: flex; flex-wrap: wrap; justify-content: center; background-color: rgba(233,233,233,0.5); padding: 0.75rem; border-radius: 0.375rem; min-height: 146px; /* Ensure space for one row of cards + margin */ }

        .opponent-hand {
            display: flex; flex-wrap: wrap; justify-content: center; align-content: flex-start;
            width: 100%; flex-grow: 1; min-height: 0;
        }
        /* Smaller cards for opponents */
        .opponent-hand .card {
            width: 50px; height: 80px; font-size: 10px; margin: 3px; padding: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .opponent-hand .card .value-center { font-size: 24px; }
        .opponent-hand .card .corner-value { font-size: 10px; top:4px; left:4px;}
        .opponent-hand .card .bottom-right {bottom:4px; right:4px;}
        .opponent-hand .card-back .card-back-text { font-size: 20px; }
        .opponent-hand .card:hover { transform: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2); } /* No hover effect for opponent cards */

        .discard-pile .card, .draw-pile .card { cursor: default; }
        .discard-pile .card:hover, .draw-pile .card:hover { transform: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .playable {
            border: 3px solid #FFC107 !important; /* Brighter yellow */
            box-shadow: 0 0 12px #FFC107, 0 0 20px #FFB300 inset, 0 5px 10px rgba(0,0,0,0.12) !important;
            transform: translateY(-4px) scale(1.03); /* Slight lift for playable cards */
        }
        .playable:hover { /* Keep hover effect consistent with playable state */
             transform: translateY(-8px) scale(1.07);
             box-shadow: 0 0 15px #FFC107, 0 0 25px #FFB300 inset, 0 8px 16px rgba(0,0,0,0.18) !important;
        }


        #color-picker-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: #ffffff; padding: 30px; border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2), 0 5px 15px rgba(0,0,0,0.15); z-index: 1000;
            border: 1px solid #DEE2E6;
        }
        .color-button {
            width: 70px; height: 70px; border-radius: 50%; margin: 10px; cursor: pointer;
            border: 4px solid transparent; /* Transparent border initially */
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .color-button:hover { transform: scale(1.12); box-shadow: 0 0 15px currentColor; border-color: currentColor; }
        .bg-red-picker { background-color: #FF3B30; }
        .bg-yellow-picker { background-color: #FFCC00; }
        .bg-green-picker { background-color: #4CD964; }
        .bg-blue-picker { background-color: #007AFF; }

        /* Message Log Styles */
        #message-log-container { background-color: #FFFFFF; color: #333; box-shadow: 0 2px 5px rgba(0,0,0,0.05); border: 1px solid #EAEAEA; }
        #message-area .msg { padding: 5px 10px; border-radius: 6px; margin-bottom: 5px; line-height: 1.45; transition: background-color 0.3s; }
        #message-area .msg:last-child { animation: fadeInMessage 0.5s ease-out; } /* Animate last message */
        @keyframes fadeInMessage { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        #message-area .msg-turn { background-color: #E3F2FD; color: #0D47A1; border-left: 4px solid #2196F3; font-weight: 600;}
        #message-area .msg-action { background-color: #E0F2F1; color: #004D40; }
        #message-area .msg-effect { background-color: #FFF8E1; color: #E65100; }
        #message-area .msg-draw { background-color: #F3E5F5; color: #4A148C; }
        #message-area .msg-uno { background-color: #FFFDE7; color: #D32F2F; font-weight: bold; text-align: center; padding: 8px; border: 2px dashed #D32F2F;}
        #message-area .msg-win { background-color: #E8F5E9; color: #1B5E20; font-weight: bold; text-align: center; padding: 10px; font-size: 1.15em; border-top: 2px solid #4CAF50; border-bottom: 2px solid #4CAF50;}
        #message-area .msg-system { background-color: #ECEFF1; color: #37474F; }
        #message-area .msg-error { background-color: #FFEBEE; color: #B71C1C; font-weight: bold; }
        #message-area .msg-timeout { background-color: #FFF9C4; color: #F57F17; border-left: 4px solid #FBC02D;}


        .current-color-indicator {
            width: 28px; height: 28px; border-radius: 50%; display: inline-block;
            margin-left: 12px; vertical-align: middle; border: 2px solid #BDBDBD;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15), inset 0 1px 2px rgba(0,0,0,0.1); /* Added inset shadow */
        }
        #player-setup { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.9); z-index: 2000; backdrop-filter: blur(5px); } /* Added backdrop filter */
        .setup-button {
            transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
            border-radius: 10px; font-weight: 600;
            padding-top: 0.75rem; /* 12px */
            padding-bottom: 0.75rem; /* 12px */
            padding-left: 1.5rem; /* 24px */
            padding-right: 1.5rem; /* 24px */
            /* margin: 10px; */ /* Margin will be handled by space-x/space-y on parent */
            font-size: 1.1rem;
            border: none; color: white;
            min-width: 140px; /* Ë®≠ÂÆöÊúÄÂ∞èÂØ¨Â∫¶‰ª•Ê±Ç‰∏ÄËá¥ */
            text-align: center; /* Á¢∫‰øùÊñáÂ≠óÂú®ÊåâÈàïÂÖßÂ±Ö‰∏≠ */
            flex-shrink: 0; /* Èò≤Ê≠¢Âú® flex ÂÆπÂô®‰∏≠Ë¢´Â£ìÁ∏Æ */
        }
        .setup-button:hover { transform: translateY(-4px) scale(1.03); box-shadow: 0 6px 12px rgba(0,0,0,0.25); }
        .setup-button:active { transform: translateY(-1px) scale(1.01); }
        .btn-blue { background-color: #2196F3; } .btn-blue:hover { background-color: #1976D2; }
        .btn-green { background-color: #4CAF50; } .btn-green:hover { background-color: #388E3C; }
        .btn-red { background-color: #F44336; } .btn-red:hover { background-color: #D32F2F; }


        .game-title { font-family: 'Paytone One', 'Arial Black', sans-serif; color: #007AFF; text-shadow: 2px 2px 0px #CDE6FF, 3px 3px 0px #A8D3FF, 4px 4px 5px rgba(0,0,0,0.1); }
        .table-bg { background-color: #26A69A; /* Teal table color */ border-radius: 12px; }

        @keyframes cardDropToDiscardAnimation { /* Enhanced animation */
            0% { transform: translateY(-90px) rotate(-20deg) scale(0.75); opacity: 0.5; }
            60% { transform: translateY(15px) rotate(5deg) scale(1.05); opacity: 1; }
            100% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
        }
        .card-animate-to-discard { animation: cardDropToDiscardAnimation 0.45s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: relative; z-index: 10; }

        @keyframes cardDrawAnimation { /* Animation for drawing a card */
            from { transform: scale(0.8) translateY(20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
        .card-animate-draw { animation: cardDrawAnimation 0.3s ease-out; }


        #uno-callout {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 30px 60px; background-color: #FFEB3B; /* Brighter yellow */ color: #D32F2F; font-size: 6.5rem; font-weight: 900;
            border-radius: 30px; box-shadow: 0 0 50px rgba(0,0,0,0.5), 0 0 0 10px rgba(255,255,255,0.3); z-index: 3000; text-align: center;
            text-shadow: 3px 3px 0px rgba(255,255,255,0.7), -1px -1px 0 #A50000, 1px -1px 0 #A50000, -1px 1px 0 #A50000, 1px 1px 0 #A50000;
            border: 8px solid #C62828; font-family: 'Paytone One', sans-serif;
            animation: unoPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes unoPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); }
        }


        .game-button {
            padding: 12px 24px; border-radius: 10px; font-weight: bold; text-transform: uppercase;
            letter-spacing: 0.8px; box-shadow: 0 3px 7px rgba(0,0,0,0.15); transition: all 0.2s ease-out;
            border: none; font-size: 0.9rem;
        }
        .game-button:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 5px 10px rgba(0,0,0,0.2); }
        .game-button:active { transform: translateY(-1px) scale(1.01); box-shadow: 0 2px 5px rgba(0,0,0,0.15); }

        #end-turn-button { background-color: #FFC107; color: #424242; } /* Amber */
        #end-turn-button:hover { background-color: #FFB300; }
        #restart-button { background-color: #007AFF; color: white; }
        #restart-button:hover { background-color: #005ECC; }

        /* Utility class for hidden elements */
        .hidden { display: none !important; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;600;700;900&family=Paytone+One&display=swap" rel="stylesheet">
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Player Setup Modal -->
    <div id="player-setup" class="fixed inset-0 bg-opacity-90 flex items-center justify-center z-2000">
        <div class="bg-white p-8 sm:p-10 rounded-xl shadow-2xl text-center max-w-md w-full mx-4">
            <h2 class="text-3xl font-bold mb-8 text-gray-800">ÈÅ∏ÊìáÈõªËÖ¶Â∞çÊâãÊï∏Èáè</h2>
            <!--
                - Removed space-y-3 for small screens, rely on flex-wrap for stacking if needed.
                - Kept sm:flex sm:justify-center for horizontal layout on small screens and up.
                - Added sm:gap-4 for consistent spacing between buttons on sm screens and up.
                  (Tailwind's space-x-* utilities don't work well if flex items wrap, gap is better)
                - Added flex-wrap to allow buttons to wrap on very small screens if necessary,
                  though with min-width this might be less of an issue.
            -->
            <div class="flex flex-wrap justify-center gap-4">
                <button data-num-computers="1" class="setup-button btn-blue">1 ‰ΩçÈõªËÖ¶</button>
                <button data-num-computers="2" class="setup-button btn-green">2 ‰ΩçÈõªËÖ¶</button>
                <button data-num-computers="3" class="setup-button btn-red">3 ‰ΩçÈõªËÖ¶</button>
            </div>
        </div>
    </div>

    <!-- UNO Callout -->
    <div id="uno-callout" class="hidden">UNO!</div>

    <!-- Main Game Board -->
    <div id="game-board" class="w-full max-w-7xl mx-auto p-4 sm:p-6 rounded-xl shadow-2xl hidden">
        <h1 class="text-5xl sm:text-6xl font-bold text-center mb-6 sm:mb-8 game-title">UNO</h1>

        <!-- Opponents Area -->
        <div id="opponents-area-container">
            <!-- Opponent areas will be dynamically inserted here -->
        </div>

        <!-- Table Area (Draw/Discard Piles, Game Info) -->
        <div id="table-area" class="flex flex-col sm:flex-row justify-around items-center mb-6 sm:mb-8 p-4 sm:p-5 table-bg shadow-lg">
            <div id="draw-pile-container" class="text-center mb-4 sm:mb-0">
                <h3 class="text-white font-semibold text-base mb-1">ÊäΩÁâåÂ†Ü</h3>
                <div id="draw-pile" class="draw-pile mt-1.5 min-h-[130px] min-w-[85px] flex justify-center items-center">
                    <!-- Draw pile card will be here -->
                </div>
                <p class="text-white text-sm mt-1.5">(<span id="draw-pile-count">0</span> Âºµ)</p>
            </div>

            <div id="center-info-area" class="flex flex-col items-center justify-center text-center mx-2 sm:mx-4 my-3 sm:my-0 px-3 py-2 rounded-md" style="background-color: rgba(0,0,0,0.15);">
                <div id="active-player-display" class="text-white font-semibold text-lg mb-1">Ëº™Âà∞ ÊÇ® ‰∫Ü</div>
                <div id="center-turn-timer-display" class="text-yellow-300 font-medium text-base">ÊÄùËÄÉÊôÇÈñì: 10s</div>
            </div>

            <div id="discard-pile-container" class="text-center mt-4 sm:mt-0">
                <h3 class="text-white font-semibold text-base mb-1">Ê£ÑÁâåÂ†Ü</h3>
                <div id="discard-pile" class="discard-pile mt-1.5 min-h-[130px] min-w-[85px] flex justify-center items-center">
                    <!-- Discard pile card will be here -->
                </div>
                 <p class="text-white text-sm mt-1.5">Áï∂ÂâçÈ°èËâ≤: <span id="current-color-text">ÁÑ°</span> <span id="current-color-indicator-ui" class="current-color-indicator"></span></p>
            </div>
        </div>

        <!-- Player Area -->
        <div id="player-area" class="mb-6 p-3 rounded-lg transition-all duration-300 ease-in-out">
            <h2 class="text-2xl font-semibold mb-3 text-center text-gray-800">ÊÇ®ÁöÑÊâãÁâå (<span id="player-card-count">0</span>)</h2>
            <div id="player-hand" class="player-hand-container">
                <!-- Player cards will be here -->
            </div>
        </div>

        <!-- Message Log & Status -->
        <div id="message-log-container" class="bg-white p-4 rounded-lg shadow border border-gray-200 mb-6">
            <h4 class="text-md font-semibold text-gray-700 mb-2 border-b pb-2">ÈÅäÊà≤Ë®òÈåÑ</h4>
            <div id="message-area" class="h-32 overflow-y-auto text-sm space-y-1 pr-2 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100">
                <!-- Messages will appear here -->
            </div>
            <div id="current-status-message" class="mt-3 text-center text-lg font-semibold text-gray-800 min-h-[1.5em] py-2 border-t pt-3">
                <!-- Current game prompts will appear here -->
            </div>
        </div>

        <!-- Controls -->
        <div id="controls" class="text-center mt-6 sm:mt-8">
            <button id="end-turn-button" class="game-button hidden mr-4">ÁµêÊùüÂõûÂêà</button>
            <button id="restart-button" class="game-button">ÈáçÊñ∞ÈñãÂßã</button>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="color-picker-modal" class="hidden">
        <h3 class="text-2xl font-semibold mb-5 text-center text-gray-800">ÈÅ∏Êìá‰∏ÄÂÄãÈ°èËâ≤</h3>
        <div class="flex justify-center">
            <button class="color-button bg-red-picker" data-color="red" aria-label="ÈÅ∏ÊìáÁ¥ÖËâ≤"></button>
            <button class="color-button bg-yellow-picker" data-color="yellow" aria-label="ÈÅ∏ÊìáÈªÉËâ≤"></button>
            <button class="color-button bg-green-picker" data-color="green" aria-label="ÈÅ∏ÊìáÁ∂†Ëâ≤"></button>
            <button class="color-button bg-blue-picker" data-color="blue" aria-label="ÈÅ∏ÊìáËóçËâ≤"></button>
        </div>
    </div>

    <script>
        // SVG Icons for action cards
        const ICONS = {
            skip: `<svg viewBox="0 0 100 100" class="action-icon"><circle cx="50" cy="50" r="40" stroke-width="10" stroke="currentColor" fill="none"/><line x1="25" y1="25" x2="75" y2="75" stroke-width="12" stroke="currentColor"/></svg>`,
            reverse: `<svg viewBox="0 0 100 100" class="action-icon"><path d="M 25 50 A 25 25 0 1 1 75 50 L 75 70 L 90 50 L 75 30 L 75 50" stroke-width="10" stroke="currentColor" fill="none"/><path d="M 75 50 A 25 25 0 1 1 25 50 L 25 30 L 10 50 L 25 70 L 25 50" stroke-width="10" stroke="currentColor" fill="none" transform="rotate(180 50 50)"/></svg>`,
            drawTwo: `<span class="value-center" style="font-size:36px; line-height:1;">+2</span>`,
            wild: `<span class="value-center" style="font-size:36px; line-height:1;">W</span>`, // Kept simple, wild-center-icon handles visuals
            wildDrawFour: `<span class="value-center" style="font-size:30px; line-height:1;">+4</span>` // Kept simple
        };

        const game = {
            // Game state variables
            deck: [],
            players: [],
            discardPile: [],
            currentPlayerIndex: 0,
            currentColorInPlay: '', // Stores the color chosen for a Wild card
            gameDirection: 1, // 1 for forward, -1 for reverse
            isGameOver: false,
            humanPlayerDrewAndCanPlay: false, // Flag if human drew a card and can either play it or pass

            // Timers
            turnTimerId: null,
            computerThinkingTimerId: null,
            turnTimerDuration: 10000, // 10 seconds for a turn
            turnTimeRemaining: 10,
            turnTimerIntervalId: null,

            // DOM Element Cache
            playerSetupElement: document.getElementById('player-setup'),
            gameBoardElement: document.getElementById('game-board'),
            opponentsAreaContainerElement: document.getElementById('opponents-area-container'),
            playerHandElement: document.getElementById('player-hand'),
            playerAreaElement: document.getElementById('player-area'),
            discardPileElement: document.getElementById('discard-pile'),
            drawPileElement: document.getElementById('draw-pile'),
            messageLogElement: document.getElementById('message-area'),
            currentStatusMessageElement: document.getElementById('current-status-message'),
            activePlayerDisplayElement: document.getElementById('active-player-display'),
            centerTurnTimerDisplayElement: document.getElementById('center-turn-timer-display'),
            colorPickerModal: document.getElementById('color-picker-modal'),
            drawPileCountElement: document.getElementById('draw-pile-count'),
            playerCardCountElement: document.getElementById('player-card-count'), // Cached player card count
            currentColorTextElement: document.getElementById('current-color-text'),
            currentColorIndicatorUIElement: document.getElementById('current-color-indicator-ui'),
            unoCalloutElement: document.getElementById('uno-callout'),
            endTurnButtonElement: document.getElementById('end-turn-button'),

            /**
             * Initializes the game by setting up event listeners for setup and controls.
             */
            init: function() {
                this.playerSetupElement.querySelectorAll('.setup-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const numComputers = parseInt(e.target.dataset.numComputers);
                        this.playerSetupElement.classList.add('hidden');
                        this.gameBoardElement.classList.remove('hidden');
                        this.startGame(numComputers);
                    });
                });

                document.getElementById('restart-button').addEventListener('click', () => {
                     this.clearTurnTimer(); // Clear any active timers
                     this.gameBoardElement.classList.add('hidden'); // Hide game board
                     this.playerSetupElement.classList.remove('hidden'); // Show setup screen
                     this.opponentsAreaContainerElement.innerHTML = ''; // Clear opponent areas
                     this.opponentsAreaContainerElement.className = 'opponents-area-container'; // Reset classes
                     this.endTurnButtonElement.classList.add('hidden'); // Hide end turn button
                });

                this.colorPickerModal.querySelectorAll('.color-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        this.selectColorForWild(e.target.dataset.color);
                    });
                });

                this.endTurnButtonElement.addEventListener('click', () => {
                    // This button is only visible if the human player drew a card and can choose to pass.
                    if (this.humanPlayerDrewAndCanPlay) {
                        this.clearTurnTimer();
                        this.humanPlayerDrewAndCanPlay = false; // Reset flag
                        this.endTurnButtonElement.classList.add('hidden');
                        this.logMessage(`${this.players[0].name} ÈÅ∏ÊìáÁµêÊùüÂõûÂêà„ÄÇ`, 'action');
                        this.endPlayerTurn(0); // End human's turn
                    }
                });
            },

            /**
             * Logs a message to the game log area.
             * @param {string} message - The message to log.
             * @param {string} type - The type of message (e.g., 'system', 'action', 'uno').
             */
            logMessage: function(message, type = 'system') {
                if (!this.messageLogElement) return;
                const msgDiv = document.createElement('div');
                msgDiv.classList.add('msg', `msg-${type}`);
                msgDiv.innerHTML = message; // Use innerHTML to render potential spans for color
                this.messageLogElement.appendChild(msgDiv);
                // Scroll to the bottom of the message log
                this.messageLogElement.scrollTop = this.messageLogElement.scrollHeight;
            },

            /**
             * Updates the current status message displayed below the game log.
             * @param {string} statusMessage - The message to display.
             */
            updateCurrentStatus: function(statusMessage) {
                if (!this.currentStatusMessageElement) return;
                let finalMessage = statusMessage || "";

                // Append current color information if relevant and a color is chosen
                if (this.currentColorInPlay && this.currentColorInPlay !== 'black' && this.currentColorInPlay !== 'Êú™ÈÅ∏' && this.currentColorInPlay !== 'ÁÑ°') {
                    if (finalMessage) finalMessage += " ";
                    finalMessage += `(Áï∂ÂâçÈ°èËâ≤: <span style="color:${this.getCSSColor(this.currentColorInPlay.split('-')[0])}; font-weight:bold; text-shadow: 0 0 3px rgba(0,0,0,0.3);">${this.getChineseColorName(this.currentColorInPlay)}</span>)`;
                }
                this.currentStatusMessageElement.innerHTML = finalMessage;
            },

            /**
             * Clears all active turn timers and computer thinking timers.
             */
            clearTurnTimer: function() {
                if (this.turnTimerId) clearTimeout(this.turnTimerId);
                if (this.turnTimerIntervalId) clearInterval(this.turnTimerIntervalId);
                this.turnTimerId = null;
                this.turnTimerIntervalId = null;
                this.turnTimeRemaining = this.turnTimerDuration / 1000; // Reset remaining time
                if (this.centerTurnTimerDisplayElement) {
                    this.centerTurnTimerDisplayElement.textContent = `ÊÄùËÄÉÊôÇÈñì: ${this.turnTimeRemaining}s`;
                    this.centerTurnTimerDisplayElement.classList.remove('text-red-500', 'font-bold'); // Reset style
                }
                if (this.computerThinkingTimerId) {
                    clearTimeout(this.computerThinkingTimerId);
                    this.computerThinkingTimerId = null;
                }
            },

            /**
             * Starts the turn timer for the specified player.
             * @param {number} playerIndex - The index of the current player.
             */
            startTurnTimer: function(playerIndex) {
                this.clearTurnTimer();
                const player = this.players[playerIndex];
                this.turnTimeRemaining = this.turnTimerDuration / 1000;

                if (this.centerTurnTimerDisplayElement) {
                    this.centerTurnTimerDisplayElement.textContent = `ÊÄùËÄÉÊôÇÈñì: ${this.turnTimeRemaining}s`;
                    this.centerTurnTimerDisplayElement.classList.remove('text-red-500', 'font-bold');

                    this.turnTimerIntervalId = setInterval(() => {
                        this.turnTimeRemaining--;
                        if (this.centerTurnTimerDisplayElement) {
                            this.centerTurnTimerDisplayElement.textContent = `ÊÄùËÄÉÊôÇÈñì: ${this.turnTimeRemaining}s`;
                            if (this.turnTimeRemaining <= 3 && this.turnTimeRemaining > 0) { // Warning styling
                                this.centerTurnTimerDisplayElement.classList.add('text-red-500', 'font-bold');
                            }
                        }
                        if (this.turnTimeRemaining < 0) {
                            clearInterval(this.turnTimerIntervalId);
                            if (this.centerTurnTimerDisplayElement) this.centerTurnTimerDisplayElement.textContent = 'Ë∂ÖÊôÇ!';
                        }
                    }, 1000);
                }

                this.turnTimerId = setTimeout(() => {
                    if (this.isGameOver || this.currentPlayerIndex !== playerIndex) {
                        this.clearTurnTimer();
                        return;
                    }
                    if (this.centerTurnTimerDisplayElement) this.centerTurnTimerDisplayElement.textContent = 'Ë∂ÖÊôÇ!';
                    this.logMessage(`${player.name} Ë∂ÖÊôÇÔºÅËá™ÂãïÊäΩ‰∏ÄÂºµÁâå‰∏¶ÁµêÊùüÂõûÂêà„ÄÇ`, 'timeout');
                    this.updateCurrentStatus(`${player.name} Ë∂ÖÊôÇÔºÅ`);
                    this.makePlayerDrawCards(playerIndex, 1, true); // Pass true to animate draw
                    this.logMessage(`${player.name} Âõ†Ë∂ÖÊôÇÊäΩ‰∫Ü‰∏ÄÂºµÁâå„ÄÇ`, 'draw');

                    // Render updates after drawing
                    this.renderPlayerHand(playerIndex);
                    this.renderDrawPile();

                    if (player.hand.length === 1) {
                        this.showUnoCallout(player.name);
                        this.logMessage(`${player.name} UNO!`, 'uno');
                    }
                    if (this.checkWinCondition(playerIndex)) return;

                    if (player.isComputer && this.computerThinkingTimerId) {
                        clearTimeout(this.computerThinkingTimerId);
                        this.computerThinkingTimerId = null;
                    }
                    this.endPlayerTurn(playerIndex);
                }, this.turnTimerDuration);
            },

            /**
             * Configures players based on the number of computer opponents selected.
             * @param {number} numComputers - The number of computer opponents.
             */
            configurePlayers: function(numComputers) {
                this.players = [];
                this.players.push({ id: 'player_0', name: 'ÊÇ®', hand: [], isComputer: false, isSkipped: false, elementIdPrefix: 'player' });

                this.opponentsAreaContainerElement.innerHTML = ''; // Clear previous opponents
                this.opponentsAreaContainerElement.className = 'opponents-area-container mb-6'; // Reset classes
                if (numComputers === 1) this.opponentsAreaContainerElement.classList.add('one-opponent');
                else if (numComputers === 2) this.opponentsAreaContainerElement.classList.add('two-opponents');
                else if (numComputers === 3) this.opponentsAreaContainerElement.classList.add('three-opponents');

                for (let i = 0; i < numComputers; i++) {
                    const opponentId = `opponent_${i+1}`;
                    this.players.push({ id: opponentId, name: `ÈõªËÖ¶ ${i+1}`, hand: [], isComputer: true, isSkipped: false, elementIdPrefix: opponentId });
                    const opponentDiv = document.createElement('div');
                    opponentDiv.id = `${opponentId}-area`;
                    opponentDiv.classList.add('opponent-area');
                    opponentDiv.innerHTML = `<h3 class="text-sm font-semibold mb-2 text-gray-700">${this.players[i+1].name} (<span id="${opponentId}-card-count">0</span>)</h3><div id="${opponentId}-hand" class="opponent-hand"></div>`;
                    this.opponentsAreaContainerElement.appendChild(opponentDiv);
                }
            },

            /**
             * Starts a new game: resets state, creates deck, deals cards, and starts the first turn.
             * @param {number} numComputers - Number of computer opponents.
             */
            startGame: function(numComputers) {
                this.configurePlayers(numComputers);
                this.deck = []; this.discardPile = []; this.isGameOver = false;
                this.currentPlayerIndex = 0; this.gameDirection = 1; this.currentColorInPlay = '';
                this.players.forEach(p => { p.hand = []; p.isSkipped = false; });
                this.humanPlayerDrewAndCanPlay = false; this.endTurnButtonElement.classList.add('hidden');

                this.messageLogElement.innerHTML = '';
                this.logMessage('Ê≠£Âú®Ê∫ñÂÇôÊñ∞ÈÅäÊà≤...', 'system');
                this.activePlayerDisplayElement.textContent = 'ÈÅäÊà≤ÈñãÂßãÔºÅ';
                this.updateCurrentStatus(''); // Clear status prompts

                this.hideColorPicker(); this.createDeck(); this.shuffleDeck(); this.dealCards();

                // Draw first card for discard pile, must not be Wild Draw Four.
                let firstCard = this.drawCardFromDeck();
                while (firstCard.type === 'wildDrawFour') {
                    this.deck.unshift(firstCard); // Put back and reshuffle
                    this.shuffleDeck();
                    firstCard = this.drawCardFromDeck();
                }
                this.discardPile.push(firstCard);
                this.currentColorInPlay = firstCard.color === 'black' ? null : firstCard.color;

                this.renderAll(); // Initial render of all game elements
                // Animate the first card to the discard pile
                const firstDiscardCardElement = this.discardPileElement.querySelector('.card');
                if (firstDiscardCardElement) this.animateCardToDiscardPile(firstDiscardCardElement);

                this.processTurnStart(firstCard); // Process effects of the first card and start game flow
            },

            /**
             * Processes the start of a turn, including handling the first card of the game or subsequent turns.
             * @param {object|null} initialCard - The first card dealt to the discard pile, or null for subsequent turns.
             */
            processTurnStart: function(initialCard = null) {
                const currentPlayer = this.players[this.currentPlayerIndex];
                this.activePlayerDisplayElement.textContent = `Ëº™Âà∞ ${currentPlayer.name} ‰∫Ü„ÄÇ`;
                let statusPromptForLog = "";
                let logMsg = "";

                if (initialCard) { // Handling the very first card of the game
                    logMsg = `ÈñãÂ±ÄÁâåÊòØ ${this.getCardDisplayName(initialCard)}„ÄÇ`;
                    if (initialCard.color === 'black' && initialCard.type === 'wild') { // Wild card as first card
                        statusPromptForLog = `${currentPlayer.name} Ë´ãÈÅ∏ÊìáÈ°èËâ≤„ÄÇ`;
                        logMsg += ` ${statusPromptForLog}`;
                    } else if (initialCard.type !== 'number' && initialCard.color !== 'black') { // Action card as first card
                        const { effectMsg, nextPlayerToStartChecking } = this.applyCardEffect(initialCard, -1);
                        logMsg += effectMsg; // Log effect of the first card
                        // Determine the actual starting player after the first card's effect
                        const { playerIndex: actualNextPlayerIndex } = this.determineNextActivePlayer(nextPlayerToStartChecking, false);
                        this.currentPlayerIndex = actualNextPlayerIndex;
                        const newCurrentPlayerForLog = this.players[this.currentPlayerIndex];
                        this.activePlayerDisplayElement.textContent = `Ëº™Âà∞ ${newCurrentPlayerForLog.name} ‰∫Ü„ÄÇ`;
                        logMsg += ` Ëº™Âà∞ ${newCurrentPlayerForLog.name} ‰∫Ü„ÄÇ`; // Update log for actual starting player
                    } else { // Number card as first card
                         logMsg += ` Ëº™Âà∞ ${currentPlayer.name} ‰∫Ü„ÄÇ`;
                    }
                } else { // Subsequent turns
                    logMsg = `Ëº™Âà∞ ${currentPlayer.name} ‰∫Ü„ÄÇ`;
                }

                this.renderDrawPile(); // Ensure draw pile is correctly rendered for the current turn state

                this.updateCurrentStatus(statusPromptForLog);
                this.logMessage(logMsg, 'turn');
                this.highlightCurrentPlayerTurn();
                this.startTurnTimer(this.currentPlayerIndex);

                if (initialCard && initialCard.color === 'black' && initialCard.type === 'wild') {
                    const actualCurrentPlayer = this.players[this.currentPlayerIndex];
                     if (!actualCurrentPlayer.isComputer) {
                        this.showColorPicker(false);
                    } else {
                        this.computerChooseColor(this.currentPlayerIndex, initialCard);
                    }
                    return;
                }

                if (this.players[this.currentPlayerIndex].isComputer) {
                    if (this.computerThinkingTimerId) clearTimeout(this.computerThinkingTimerId);
                    this.computerThinkingTimerId = setTimeout(() => {
                        this.computerThinkingTimerId = null;
                        if (!this.isGameOver && this.players[this.currentPlayerIndex] === currentPlayer && this.currentPlayerIndex === this.players.indexOf(currentPlayer)) {
                           this.computerTurn(this.currentPlayerIndex);
                        }
                    }, 1800 + Math.random() * 700);
                } else {
                    this.highlightPlayableCardsForHuman();
                }
            },

            // --- Deck and Card Management ---
            createDeck: function() {
                const colors = ['red', 'yellow', 'green', 'blue'];
                this.deck = [];
                colors.forEach(color => {
                    this.deck.push({ color: color, value: '0', type: 'number', display: '0' });
                    for (let i = 0; i < 2; i++) {
                        for (let v = 1; v < 10; v++) this.deck.push({ color: color, value: String(v), type: 'number', display: String(v) });
                        this.deck.push({ color: color, value: 'skip', type: 'skip', display: 'üö´' });
                        this.deck.push({ color: color, value: 'reverse', type: 'reverse', display: 'üîÑ' });
                        this.deck.push({ color: color, value: 'drawTwo', type: 'drawTwo', display: '+2' });
                    }
                });
                for (let i = 0; i < 4; i++) {
                    this.deck.push({ color: 'black', value: 'wild', type: 'wild', display: 'W' });
                    this.deck.push({ color: 'black', value: 'wildDrawFour', type: 'wildDrawFour', display: 'W+4' });
                }
            },
            shuffleDeck: function() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            },
            dealCards: function() {
                this.players.forEach(player => {
                    for (let i = 0; i < 7; i++) {
                        const card = this.drawCardFromDeck();
                        if (card) player.hand.push(card);
                    }
                });
            },
            drawCardFromDeck: function() {
                if (this.deck.length === 0) this.refillDeckFromDiscardPile();
                if (this.deck.length === 0) {
                    this.logMessage("ÊäΩÁâåÂ†ÜÂ∑≤Á©∫ÔºåÁÑ°Ê≥ïÊäΩÁâåÔºÅ", 'error'); return null;
                }
                return this.deck.pop();
            },
            refillDeckFromDiscardPile: function() {
                if (this.discardPile.length <= 1) return; // Not enough cards to refill
                const topCard = this.discardPile.pop();
                this.deck = [...this.discardPile];
                this.discardPile = [topCard];
                this.shuffleDeck();
                this.logMessage("ÊäΩÁâåÂ†ÜÂ∑≤Á©∫ÔºåÂ∑≤ÂæûÊ£ÑÁâåÂ†ÜÈáçÊñ∞Ê¥óÁâå„ÄÇ", 'system');
                this.renderDrawPile(); // Update draw pile display immediately
            },

            // --- Rendering Functions ---
            renderCard: function(cardData, isFaceUp = true, isPlayable = false, cardIndexInHand = -1, forOpponent = false) {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                let centerContentHTML = '';
                let cornerDisplay = cardData.display;

                if (isFaceUp) {
                    cardDiv.classList.add(`card-${cardData.color}`);
                    switch(cardData.type) {
                        case 'number': centerContentHTML = `<span class="value-center">${cardData.value}</span>`; break;
                        case 'skip': centerContentHTML = ICONS.skip; if (cardData.color === 'yellow') centerContentHTML = centerContentHTML.replace('class="action-icon"', 'class="action-icon text-black"'); break;
                        case 'reverse': centerContentHTML = ICONS.reverse; if (cardData.color === 'yellow') centerContentHTML = centerContentHTML.replace('class="action-icon"', 'class="action-icon text-black"'); break;
                        case 'drawTwo': centerContentHTML = ICONS.drawTwo; break;
                        case 'wild': centerContentHTML = `<div class="wild-center-icon">${ICONS.wild}</div>`; cornerDisplay = 'W'; break;
                        case 'wildDrawFour': centerContentHTML = `<div class="wild-center-icon">${ICONS.wildDrawFour}</div>`; cornerDisplay = 'W+4'; break;
                        default: centerContentHTML = `<span class="value-center">${cardData.display || '?'}</span>`;
                    }
                    cardDiv.innerHTML = `<span class="corner-value top-left">${cornerDisplay}</span>${centerContentHTML}<span class="corner-value bottom-right">${cornerDisplay}</span>`;
                    if (isPlayable) cardDiv.classList.add('playable');

                    if (!forOpponent && this.players[0] && !this.players[0].isComputer && (this.currentPlayerIndex === 0 || this.humanPlayerDrewAndCanPlay)) {
                         cardDiv.dataset.cardIndex = cardIndexInHand;
                         cardDiv.addEventListener('click', () => this.handleHumanPlayCard(cardIndexInHand));
                    } else {
                        cardDiv.style.cursor = 'default';
                    }
                } else {
                    cardDiv.classList.add('card-back');
                    cardDiv.innerHTML = `<span class="card-back-text">UNO</span>`;
                }
                return cardDiv;
            },
            renderPlayerHand: function(playerIndex, animateNewCard = null) {
                const player = this.players[playerIndex];
                const handElement = player.isComputer ? document.getElementById(`${player.elementIdPrefix}-hand`) : this.playerHandElement;
                const cardCountElement = player.isComputer ? document.getElementById(`${player.elementIdPrefix}-card-count`) : this.playerCardCountElement;

                if (!handElement || !cardCountElement) { console.error("Hand or count element not found for", player.name); return; }

                handElement.innerHTML = '';
                const topDiscard = this.getTopDiscardCard();

                player.hand.forEach((card, index) => {
                    let cardDiv;
                    if (player.isComputer) {
                        cardDiv = this.renderCard({}, false, false, -1, true);
                    } else {
                        const isPlayable = (this.currentPlayerIndex === playerIndex || this.humanPlayerDrewAndCanPlay) && this.isCardPlayable(card, topDiscard);
                        cardDiv = this.renderCard(card, true, isPlayable, index, false);
                        if (card === animateNewCard) {
                            cardDiv.classList.add('card-animate-draw');
                        }
                    }
                    handElement.appendChild(cardDiv);
                });
                cardCountElement.textContent = player.hand.length;
            },
            renderAllPlayerHands: function() { this.players.forEach((_, index) => this.renderPlayerHand(index)); },
            renderDiscardPile: function() {
                this.discardPileElement.innerHTML = '';
                const topCard = this.getTopDiscardCard();
                if (topCard) {
                    const cardDiv = this.renderCard(topCard, true, false, -1, true);
                    cardDiv.style.cursor = 'default';
                    this.discardPileElement.appendChild(cardDiv);
                } else {
                    this.discardPileElement.innerHTML = '<div class="w-[85px] h-[130px] border-2 border-dashed border-gray-400 rounded-lg flex items-center justify-center text-gray-500 text-sm">Ê£ÑÁâåÂçÄ</div>';
                }
                this.updateCurrentColorDisplay();
            },
            animateCardToDiscardPile: function(cardElement) {
                 if (cardElement) {
                    cardElement.classList.remove('card-animate-to-discard');
                    void cardElement.offsetWidth;
                    cardElement.classList.add('card-animate-to-discard');
                 }
            },
            updateCurrentColorDisplay: function() {
                const topDiscard = this.getTopDiscardCard();
                let displayColor = this.currentColorInPlay;

                if (!displayColor && topDiscard && topDiscard.color !== 'black') displayColor = topDiscard.color;
                else if (!displayColor && topDiscard && topDiscard.color === 'black') displayColor = 'Êú™ÈÅ∏';

                this.currentColorTextElement.textContent = this.getChineseColorName(displayColor || 'ÁÑ°');
                this.currentColorIndicatorUIElement.className = 'current-color-indicator';
                if (displayColor && displayColor !== 'Êú™ÈÅ∏' && displayColor !== 'ÁÑ°') {
                    this.currentColorIndicatorUIElement.style.backgroundColor = this.getCSSColor(displayColor.split('-')[0]);
                } else {
                    this.currentColorIndicatorUIElement.style.backgroundColor = '#B0BEC5';
                }
            },
            getCSSColor: function(colorName) {
                switch (colorName) {
                    case 'red': return '#FF3B30'; case 'yellow': return '#FFCC00'; case 'green': return '#4CD964';
                    case 'blue': return '#007AFF'; case 'black': return '#1C1C1E'; default: return '#B0BEC5';
                }
            },
            renderDrawPile: function() {
                this.drawPileElement.innerHTML = '';
                if (this.deck.length > 0) {
                    const cardBack = this.renderCard({}, false);
                    if (this.players[0] && this.currentPlayerIndex === 0 && !this.players[0].isComputer && !this.humanPlayerDrewAndCanPlay) {
                        cardBack.addEventListener('click', () => this.handleHumanDrawCard());
                        cardBack.style.cursor = 'pointer';
                        cardBack.classList.add('hover:scale-105', 'transition-transform', 'duration-150');
                    } else { cardBack.style.cursor = 'default'; }
                    this.drawPileElement.appendChild(cardBack);
                } else {
                    this.drawPileElement.innerHTML = '<div class="w-[85px] h-[130px] border-2 border-dashed border-gray-400 rounded-lg flex items-center justify-center text-gray-500 text-sm">Á©∫</div>';
                }
                this.drawPileCountElement.textContent = this.deck.length;
            },
            renderAll: function() {
                if(this.isGameOver) return;
                this.renderAllPlayerHands(); this.renderDiscardPile(); this.renderDrawPile();
            },
            highlightPlayableCardsForHuman: function() {
                 if (this.players[0] && (this.currentPlayerIndex === 0 || this.humanPlayerDrewAndCanPlay) && !this.players[0].isComputer) {
                    this.renderPlayerHand(0);
                 }
            },
            highlightCurrentPlayerTurn: function() {
                this.players.forEach((player, index) => {
                    const areaElement = document.getElementById(`${player.elementIdPrefix}-area`);
                    if (areaElement && player.isComputer) areaElement.classList.toggle('active-turn', index === this.currentPlayerIndex);
                });
                if (this.players[0]) this.playerAreaElement.classList.toggle('active-human-player-area', this.currentPlayerIndex === 0 && !this.players[0].isComputer);
            },

            // --- Game Logic Helpers ---
            getChineseColorName: function(color) {
                if (!color) return 'ÁÑ°';
                switch (color.replace('-picker','')) {
                    case 'red': return 'Á¥ÖËâ≤'; case 'yellow': return 'ÈªÉËâ≤'; case 'green': return 'Á∂†Ëâ≤';
                    case 'blue': return 'ËóçËâ≤'; case 'black': return 'ÈªëËâ≤ (Ëê¨Áî®)'; default: return color;
                }
            },
            getCardDisplayName: function(card) {
                if (!card) return '';
                const colorName = card.color === 'black' ? '' : this.getChineseColorName(card.color);
                let valueName = card.display;
                switch(card.type) {
                    case 'skip': valueName = 'Á¶ÅÊ≠¢'; break; case 'reverse': valueName = 'ÂèçËΩâ'; break;
                    case 'drawTwo': valueName = '+2'; break; case 'wild': valueName = 'Ëê¨Áî®Áâå'; break;
                    case 'wildDrawFour': valueName = 'ÁéãÁâå+4'; break;
                }
                return `${colorName} ${valueName}`.trim();
            },
            isCardPlayable: function(cardToPlay, topDiscardCard) {
                if (!topDiscardCard) return true;
                if (cardToPlay.color === 'black') return true;
                if (this.currentColorInPlay && this.currentColorInPlay !== 'black') {
                    return cardToPlay.color === this.currentColorInPlay || cardToPlay.value === topDiscardCard.value;
                }
                return cardToPlay.color === topDiscardCard.color || cardToPlay.value === topDiscardCard.value;
            },
            getTopDiscardCard: function() { return this.discardPile.length > 0 ? this.discardPile[this.discardPile.length - 1] : null; },
            getNextPlayerIndex: function(currentIndex, direction) {
                if (currentIndex === -1) return direction === 1 ? 0 : this.players.length - 1;
                let nextIndex = currentIndex + direction;
                if (nextIndex >= this.players.length) nextIndex = 0;
                if (nextIndex < 0) nextIndex = this.players.length - 1;
                return nextIndex;
            },
            /**
             * Determines the next active player, consuming any 'isSkipped' flags.
             * Does NOT generate log messages for skips it consumes.
             * @param {number} startingPlayerIndex - The index to start checking from.
             * @param {boolean} advanceOneStep - Whether to advance one step before starting checks.
             * @returns {{playerIndex: number, message: string}} - The index of the next active player and an empty message string.
             */
            determineNextActivePlayer: function(startingPlayerIndex, advanceOneStep = false) {
                let nextIdx = advanceOneStep ? this.getNextPlayerIndex(startingPlayerIndex, this.gameDirection) : startingPlayerIndex;
                if (nextIdx < 0 || nextIdx >= this.players.length) { nextIdx = 0; }

                while (this.players[nextIdx].isSkipped) {
                    this.players[nextIdx].isSkipped = false; // Consume the skip
                    // Log message for "previously marked skip" is removed here.
                    // The skip effect is announced when the card is played.
                    nextIdx = this.getNextPlayerIndex(nextIdx, this.gameDirection);
                }
                return { playerIndex: nextIdx, message: "" }; // Always return empty message
            },

            // --- Player Actions ---
            handleHumanPlayCard: function(cardIndexInHand) {
                if (this.isGameOver || (this.currentPlayerIndex !== 0 && !this.humanPlayerDrewAndCanPlay) || !this.players[0] || this.players[0].isComputer) return;

                const player = this.players[0];
                const card = player.hand[cardIndexInHand];
                const topDiscard = this.getTopDiscardCard();

                if (this.isCardPlayable(card, topDiscard)) {
                    this.clearTurnTimer();
                    player.hand.splice(cardIndexInHand, 1);
                    this.discardPile.push(card);
                    const cardName = this.getCardDisplayName(card);
                    this.logMessage(`${player.name} Âá∫‰∫Ü ${cardName}.`, 'action');
                    this.currentColorInPlay = card.color === 'black' ? null : card.color;
                    this.humanPlayerDrewAndCanPlay = false;
                    this.endTurnButtonElement.classList.add('hidden');
                    this.renderPlayerHand(0);
                    this.renderDiscardPile();
                    if (this.discardPileElement.firstChild) this.animateCardToDiscardPile(this.discardPileElement.firstChild);

                    if (card.color === 'black') {
                        this.updateCurrentStatus("Ë´ãÈÅ∏Êìá‰∏ÄÂÄãÈ°èËâ≤„ÄÇ");
                        this.showColorPicker(card.type === 'wildDrawFour');
                        return;
                    }
                    this.processCardPlay(card, 0);
                } else {
                    this.logMessage("ÈÄôÂºµÁâå‰∏çËÉΩÂá∫ÔºÅ", 'error');
                    this.updateCurrentStatus("Ë´ãÈÅ∏ÊìáÂÖ∂‰ªñÁâåÊàñÊäΩÁâå„ÄÇ");
                    const cardElement = this.playerHandElement.querySelectorAll('.card')[cardIndexInHand];
                    if (cardElement) {
                        cardElement.classList.add('animate-shake');
                        setTimeout(() => cardElement.classList.remove('animate-shake'), 300);
                    }
                }
            },
            handleHumanDrawCard: function() {
                if (this.isGameOver || this.currentPlayerIndex !== 0 || !this.players[0] || this.players[0].isComputer || this.humanPlayerDrewAndCanPlay) return;
                this.clearTurnTimer();
                const player = this.players[0];
                const drawnCard = this.drawCardFromDeck();

                if (drawnCard) {
                    player.hand.push(drawnCard);
                    const drawnCardName = this.getCardDisplayName(drawnCard);
                    this.logMessage(`${player.name} ÊäΩ‰∫Ü‰∏ÄÂºµÁâå: ${drawnCardName}.`, 'draw');
                    const topDiscard = this.getTopDiscardCard();
                    if (this.isCardPlayable(drawnCard, topDiscard)) {
                         this.updateCurrentStatus(`ÊÇ®ÂèØ‰ª•Á´ãÂç≥ÊâìÂá∫ ${drawnCardName}ÔºåÊàñÈªûÊìä„ÄêÁµêÊùüÂõûÂêà„Äë„ÄÇ`);
                         this.humanPlayerDrewAndCanPlay = true;
                         this.endTurnButtonElement.classList.remove('hidden');
                         this.renderPlayerHand(0, drawnCard);
                         this.renderDrawPile();
                         this.highlightPlayableCardsForHuman();
                         this.startTurnTimer(0);
                    } else {
                        this.updateCurrentStatus(`ÊäΩÂà∞ÁöÑÁâåÁÑ°Ê≥ïÁ´ãÂç≥ÊâìÂá∫„ÄÇÂõûÂêàÁµêÊùü„ÄÇ`);
                        this.renderPlayerHand(0, drawnCard);
                        this.renderDrawPile();
                        this.endPlayerTurn(0);
                    }
                } else {
                    this.updateCurrentStatus(`${player.name} ÁÑ°Ê≥ïÊäΩÁâå„ÄÇÂõûÂêàÁµêÊùü„ÄÇ`);
                    this.logMessage(`${player.name} ÁÑ°Ê≥ïÊäΩÁâå (ÁâåÂ†ÜÂèØËÉΩÂ∑≤Á©∫)„ÄÇ`, 'error');
                    this.renderDrawPile();
                    this.endPlayerTurn(0);
                }
            },

            // --- Core Game Flow ---
            processCardPlay: function(playedCard, playerIndexWhoPlayed) {
                let effectLog = "";
                let nextPlayerToStartChecking;

                if (playedCard.type === 'number' || (playedCard.type === 'wild' && this.currentColorInPlay)) {
                    nextPlayerToStartChecking = this.getNextPlayerIndex(playerIndexWhoPlayed, this.gameDirection);
                } else {
                    const effectResult = this.applyCardEffect(playedCard, playerIndexWhoPlayed);
                    effectLog = effectResult.effectMsg;
                    if (effectLog) this.logMessage(effectLog.trim(), 'effect'); // Log the primary effect message
                    nextPlayerToStartChecking = effectResult.nextPlayerToStartChecking;
                }

                if (playedCard.type === 'drawTwo' || playedCard.type === 'wildDrawFour') {
                    const initialTargetPlayerIndex = this.getNextPlayerIndex(playerIndexWhoPlayed, this.gameDirection);
                    // It's possible initialTargetPlayerIndex is not the one who ultimately draws if there were prior skips,
                    // but for rendering, updating this hand is generally fine.
                    // A more robust way would be to find who *actually* drew, but this is usually okay.
                    this.renderPlayerHand(initialTargetPlayerIndex);
                }
                this.renderDrawPile();

                if (this.checkWinCondition(playerIndexWhoPlayed)) return;

                if (this.players[playerIndexWhoPlayed].hand.length === 1) {
                    this.logMessage(`${this.players[playerIndexWhoPlayed].name} UNO!`, 'uno');
                    this.showUnoCallout(this.players[playerIndexWhoPlayed].name);
                }

                // Determine the actual next player, message from here is now ignored for logging skips.
                const { playerIndex: actualNextPlayerIndex } = this.determineNextActivePlayer(nextPlayerToStartChecking, false);
                // The skipLogMsg is no longer used as determineNextActivePlayer returns an empty message.
                // if (skipLogMsg) this.logMessage(skipLogMsg.trim(), 'effect'); // This line can be removed or will do nothing.

                this.currentPlayerIndex = actualNextPlayerIndex;
                this.processTurnStart();
            },

            /**
             * Applies the effect of a played card.
             * Sets 'isSkipped' on target players and determines the next player to start checking for turn.
             * @param {object} card - The card that was played.
             * @param {number} playerIndexWhoPlayed - Index of the player who played the card.
             * @returns {{effectMsg: string, nextPlayerToStartChecking: number}}
             */
            applyCardEffect: function(card, playerIndexWhoPlayed) {
                let effectMsg = "";
                const targetPlayerIndex = playerIndexWhoPlayed === -1 ? 0 : this.getNextPlayerIndex(playerIndexWhoPlayed, this.gameDirection);
                let nextPlayerToStartChecking;

                switch (card.type) {
                    case 'skip':
                        this.players[targetPlayerIndex].isSkipped = true;
                        effectMsg = ` ${this.players[targetPlayerIndex].name} ÁöÑÂõûÂêàË¢´Ë∑≥ÈÅé„ÄÇ`;
                        nextPlayerToStartChecking = targetPlayerIndex; // Start check from the skipped player
                        break;
                    case 'reverse':
                        if (this.players.length === 2) {
                            this.players[targetPlayerIndex].isSkipped = true;
                            effectMsg = ` ÂèçËΩâÔºÅ${this.players[targetPlayerIndex].name} ÁöÑÂõûÂêàË¢´Ë∑≥ÈÅé„ÄÇ`;
                            nextPlayerToStartChecking = (playerIndexWhoPlayed === -1) ? 0 : playerIndexWhoPlayed; // Turn comes back to player who played
                        } else {
                            this.gameDirection *= -1;
                            effectMsg = ` ÊñπÂêëÂèçËΩâÔºÅ`;
                            nextPlayerToStartChecking = this.getNextPlayerIndex((playerIndexWhoPlayed === -1 ? 0 : playerIndexWhoPlayed), this.gameDirection);
                        }
                        break;
                    case 'drawTwo':
                        this.makePlayerDrawCards(targetPlayerIndex, 2, true);
                        this.players[targetPlayerIndex].isSkipped = true;
                        effectMsg = ` ${this.players[targetPlayerIndex].name} ÊäΩÂÖ©ÂºµÁâåÔºåÂõûÂêàÁµêÊùü„ÄÇ`;
                        // Log of drawing cards is now part of makePlayerDrawCards if needed, or here.
                        // For consistency, let's ensure it's logged.
                        if (!effectMsg.includes("ÊäΩ‰∫Ü")) { // Avoid double logging if makePlayerDrawCards logs it
                             this.logMessage(`${this.players[targetPlayerIndex].name} ÊäΩ‰∫Ü 2 ÂºµÁâå„ÄÇ`, 'draw');
                        }
                        nextPlayerToStartChecking = targetPlayerIndex;
                        break;
                    case 'wild':
                        // Color is chosen elsewhere. nextPlayerToStartChecking is simply the next in sequence.
                        nextPlayerToStartChecking = this.getNextPlayerIndex(playerIndexWhoPlayed, this.gameDirection);
                        break;
                    case 'wildDrawFour':
                        this.makePlayerDrawCards(targetPlayerIndex, 4, true);
                        this.players[targetPlayerIndex].isSkipped = true;
                        effectMsg = ` ${this.players[targetPlayerIndex].name} ÊäΩÂõõÂºµÁâåÔºåÂõûÂêàÁµêÊùü„ÄÇ`;
                        if (!effectMsg.includes("ÊäΩ‰∫Ü")) {
                            this.logMessage(`${this.players[targetPlayerIndex].name} ÊäΩ‰∫Ü 4 ÂºµÁâå„ÄÇ`, 'draw');
                        }
                        nextPlayerToStartChecking = targetPlayerIndex;
                        break;
                }
                return { effectMsg, nextPlayerToStartChecking };
            },

            makePlayerDrawCards: function(playerIndex, numCards, animate = false) {
                if (this.isGameOver) return;
                const player = this.players[playerIndex];
                let lastDrawnCardForAnimation = null;
                for (let i = 0; i < numCards; i++) {
                    const card = this.drawCardFromDeck();
                    if (card) {
                        player.hand.push(card);
                        if (animate && playerIndex === 0 && i === numCards -1 ) {
                            lastDrawnCardForAnimation = card;
                        }
                    } else break;
                }
                if (animate && playerIndex === 0 && lastDrawnCardForAnimation) {
                    this.renderPlayerHand(playerIndex, lastDrawnCardForAnimation);
                } else {
                    this.renderPlayerHand(playerIndex);
                }
            },

            selectColorForWild: function(chosenColor) {
                this.clearTurnTimer();
                this.hideColorPicker();
                const cardPlayed = this.getTopDiscardCard();
                this.currentColorInPlay = chosenColor;
                const playerName = this.players[this.currentPlayerIndex].name;
                this.logMessage(`${playerName} ÈÅ∏Êìá‰∫Ü ${this.getChineseColorName(chosenColor)}.`, 'action');
                this.updateCurrentStatus(`${playerName} ÈÅ∏Êìá‰∫Ü ${this.getChineseColorName(chosenColor)}.`);
                this.updateCurrentColorDisplay();
                this.processCardPlay(cardPlayed, this.currentPlayerIndex);
            },

            computerChooseColor: function(playerIndex, cardPlayed) {
                const computer = this.players[playerIndex];
                const colorCounts = { red: 0, yellow: 0, green: 0, blue: 0 };
                computer.hand.forEach(card => {
                    if (card.color !== 'black' && colorCounts.hasOwnProperty(card.color)) colorCounts[card.color]++;
                });
                let bestColor = 'red'; let maxCount = -1;
                const availableColors = Object.keys(colorCounts).filter(c => colorCounts[c] > 0);

                if (availableColors.length === 0) {
                    const allColors = ['red', 'yellow', 'green', 'blue'];
                    bestColor = allColors[Math.floor(Math.random() * allColors.length)];
                } else {
                    for (const color in colorCounts) if (colorCounts[color] > maxCount) { maxCount = colorCounts[color]; bestColor = color; }
                }
                this.currentColorInPlay = bestColor;
                this.logMessage(`${computer.name} ÈÅ∏Êìá‰∫Ü ${this.getChineseColorName(bestColor)}.`, 'action');
                this.updateCurrentColorDisplay();
                this.processCardPlay(cardPlayed, playerIndex);
            },

            endPlayerTurn: function(playerIndexWhoEnded) {
                this.clearTurnTimer();
                this.humanPlayerDrewAndCanPlay = false;
                this.endTurnButtonElement.classList.add('hidden');
                const { playerIndex: actualNextPlayerIndex } = this.determineNextActivePlayer(
                    this.getNextPlayerIndex(playerIndexWhoEnded, this.gameDirection), false
                );
                this.currentPlayerIndex = actualNextPlayerIndex;
                this.processTurnStart();
            },

            checkWinCondition: function(playerIndex) {
                if (this.players[playerIndex].hand.length === 0) {
                    this.clearTurnTimer();
                    this.isGameOver = true;
                    const winnerName = this.players[playerIndex].name;
                    this.logMessage(`${winnerName} Áç≤ÂãùÔºÅÈÅäÊà≤ÁµêÊùü„ÄÇ`, 'win');
                    this.activePlayerDisplayElement.textContent = `${winnerName} Áç≤ÂãùÔºÅ`;
                    this.updateCurrentStatus(`Êåâ„ÄåÈáçÊñ∞ÈñãÂßã„ÄçÂÜçÁé©‰∏ÄÂ±Ä„ÄÇ`);
                    this.centerTurnTimerDisplayElement.textContent = "ÈÅäÊà≤ÁµêÊùü";
                    this.players.forEach((p, idx) => {
                        const handEl = p.isComputer ? document.getElementById(`${p.elementIdPrefix}-hand`) : this.playerHandElement;
                        if(handEl) handEl.innerHTML = `<p class='text-center p-4 text-xl font-bold ${idx === playerIndex ? "text-green-600" : "text-red-700"}'>${idx === playerIndex ? "üèÜ Áç≤Âãù! üèÜ" : "ÈÅäÊà≤ÁµêÊùü"}</p>`;
                        const countEl = p.isComputer ? document.getElementById(`${p.elementIdPrefix}-card-count`) : this.playerCardCountElement;
                        if(countEl) countEl.textContent = '0';
                        const areaEl = document.getElementById(`${p.elementIdPrefix}-area`);
                        if(areaEl) areaEl.classList.remove('active-turn', 'active-human-player-area');
                    });
                    this.endTurnButtonElement.classList.add('hidden');
                    return true;
                }
                return false;
            },

            computerTurn: function(playerIndex) {
                if (this.isGameOver || !this.players[playerIndex] || !this.players[playerIndex].isComputer || this.currentPlayerIndex !== playerIndex) {
                    if (this.computerThinkingTimerId) { clearTimeout(this.computerThinkingTimerId); this.computerThinkingTimerId = null; }
                    return;
                }

                const computer = this.players[playerIndex];
                const topDiscard = this.getTopDiscardCard();
                let cardToPlayObj = null;
                const playableCards = [];

                for (let i = 0; i < computer.hand.length; i++) {
                    if (this.isCardPlayable(computer.hand[i], topDiscard)) {
                         if (computer.hand[i].type === 'wildDrawFour') {
                            const colorToMatch = this.currentColorInPlay || (topDiscard && topDiscard.color !== 'black' ? topDiscard.color : null);
                            if (colorToMatch) {
                                const hasMatchingColorCard = computer.hand.some(c => c.color === colorToMatch && c.type !== 'wildDrawFour');
                                if (hasMatchingColorCard) continue;
                            }
                        }
                        playableCards.push({ card: computer.hand[i], indexInHand: i });
                    }
                }
                if(playableCards.length > 0) cardToPlayObj = playableCards.find(p => p.card.color !== 'black') || playableCards.find(p => p.card.type === 'wild') || playableCards.find(p => p.card.type === 'wildDrawFour');

                if (cardToPlayObj) {
                    this.clearTurnTimer();
                    const playedCard = computer.hand.splice(cardToPlayObj.indexInHand, 1)[0];
                    this.discardPile.push(playedCard);
                    const cardName = this.getCardDisplayName(playedCard);
                    this.logMessage(`${computer.name} Âá∫‰∫Ü ${cardName}.`, 'action');
                    this.currentColorInPlay = playedCard.color === 'black' ? null : playedCard.color;
                    this.renderPlayerHand(playerIndex);
                    this.renderDiscardPile();
                    if (this.discardPileElement.firstChild) this.animateCardToDiscardPile(this.discardPileElement.firstChild);

                    if (playedCard.color === 'black') {
                        this.computerChooseColor(playerIndex, playedCard);
                        return;
                    }
                    this.processCardPlay(playedCard, playerIndex);
                } else {
                    this.clearTurnTimer();
                    const drawnCard = this.drawCardFromDeck();
                    if (drawnCard) {
                        computer.hand.push(drawnCard);
                        const drawnCardName = this.getCardDisplayName(drawnCard);
                        this.logMessage(`${computer.name} ÊäΩ‰∫Ü‰∏ÄÂºµÁâå (${drawnCardName}).`, 'draw');
                        this.renderPlayerHand(playerIndex);
                        this.renderDrawPile();
                        let canPlayDrawnCard = this.isCardPlayable(drawnCard, topDiscard);
                        if (drawnCard.type === 'wildDrawFour' && canPlayDrawnCard) {
                            const colorToMatch = this.currentColorInPlay || (topDiscard && topDiscard.color !== 'black' ? topDiscard.color : null);
                            if (colorToMatch) {
                                const hasMatchingColorCard = computer.hand.some(c => c !== drawnCard && c.color === colorToMatch && c.type !== 'wildDrawFour');
                                if (hasMatchingColorCard) canPlayDrawnCard = false;
                            }
                        }

                        if (canPlayDrawnCard) {
                            this.computerThinkingTimerId = setTimeout(() => {
                                if (this.isGameOver || this.currentPlayerIndex !== playerIndex) return;
                                const drawnCardIndexInHand = computer.hand.findIndex(c => c === drawnCard);
                                if (drawnCardIndexInHand > -1) computer.hand.splice(drawnCardIndexInHand, 1);
                                else { console.error("Drawn card not found in hand for computer play"); this.endPlayerTurn(playerIndex); return; }
                                this.discardPile.push(drawnCard);
                                this.logMessage(`${computer.name} ÊâìÂá∫‰∫ÜÊäΩÂà∞ÁöÑ ${drawnCardName}.`, 'action');
                                this.currentColorInPlay = drawnCard.color === 'black' ? null : drawnCard.color;
                                this.renderPlayerHand(playerIndex);
                                this.renderDiscardPile();
                                if (this.discardPileElement.firstChild) this.animateCardToDiscardPile(this.discardPileElement.firstChild);
                                if (drawnCard.color === 'black') {
                                    this.computerChooseColor(playerIndex, drawnCard);
                                    return;
                                }
                                this.processCardPlay(drawnCard, playerIndex);
                            }, 700 + Math.random() * 500);
                        } else {
                            this.logMessage(`${computer.name} ÊäΩÂà∞ÁöÑÁâåÁÑ°Ê≥ïÊâìÂá∫„ÄÇÂõûÂêàÁµêÊùü„ÄÇ`, 'system');
                            this.endPlayerTurn(playerIndex);
                        }
                    } else {
                         this.logMessage(`${computer.name} ÁÑ°Ê≥ïÊäΩÁâå (ÁâåÂ†ÜÂèØËÉΩÂ∑≤Á©∫)„ÄÇÂõûÂêàÁµêÊùü„ÄÇ`, 'error');
                         this.renderDrawPile();
                         this.endPlayerTurn(playerIndex);
                    }
                }
            },

            // --- UI Helpers ---
            showUnoCallout: function(playerName) {
                this.unoCalloutElement.textContent = `${playerName.replace("ÈõªËÖ¶ ", "C")} UNO!`;
                this.unoCalloutElement.classList.remove('hidden');
                setTimeout(() => { this.unoCalloutElement.classList.add('hidden'); }, 1800);
            },
            showColorPicker: function(isWildDrawFour = false) {
                this.colorPickerModal.classList.remove('hidden');
                this.colorPickerModal.dataset.isWildDrawFour = isWildDrawFour;
            },
            hideColorPicker: function() { this.colorPickerModal.classList.add('hidden'); }
        };

        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-3px); }
            }
            .animate-shake { animation: shake 0.3s ease-in-out; }
            .scrollbar-thin::-webkit-scrollbar { width: 8px; }
            .scrollbar-thin::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
            .scrollbar-thin::-webkit-scrollbar-thumb { background: #bdbdbd; border-radius: 10px; }
            .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        `;
        document.head.appendChild(styleSheet);
        document.addEventListener('DOMContentLoaded', () => game.init());
    </script>
</body>
</html>
