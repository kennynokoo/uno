<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO</title>
    <link rel="icon" href="/icon.ico" type="image/x-icon">
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1356046266101380"
     crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Bebas+Neue&family=Orbitron:wght@700;900&display=swap');

        :root {
            --primary-dark: #0a0e27;
            --primary-light: #1a1f3a;
            --accent-red: #ff1744;
            --accent-yellow: #ffc107;
            --accent-green: #00e676;
            --accent-blue: #2979ff;
            --accent-purple: #651fff;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --card-shadow: 0 10px 30px rgba(0,0,0,0.5);
            --glow-effect: 0 0 20px;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            touch-action: manipulation;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(37, 121, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 23, 68, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(0, 230, 118, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .game-container {
            position: relative;
            z-index: 2;
        }

        .glass-panel {
            background: rgba(26, 31, 58, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .neon-text {
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .action-icon { 
            width: 60%; 
            height: 60%; 
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .card {
            width: 85px; 
            height: 130px; 
            border-radius: 12px;
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
            align-items: center;
            font-weight: bold; 
            margin: 6px; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(0,0,0,0.2); 
            position: relative; 
            padding: 8px;
            transform-style: preserve-3d;
            box-shadow: 
                0 4px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2),
                inset 0 -1px 0 rgba(0,0,0,0.2);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.1) 0%, 
                transparent 50%, 
                rgba(0,0,0,0.1) 100%);
            border-radius: 10px;
            pointer-events: none;
        }

        .card:hover {
            transform: translateY(-12px) scale(1.08) rotateX(-5deg);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.5),
                0 0 20px currentColor,
                inset 0 1px 0 rgba(255,255,255,0.3);
        }

        .card .value-center { 
            font-size: 48px; 
            font-weight: 900; 
            line-height: 1; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            flex-grow: 1;
            font-family: 'Bebas Neue', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card .corner-value { 
            position: absolute; 
            font-size: 16px; 
            font-weight: 700; 
            line-height: 1;
            font-family: 'Bebas Neue', cursive;
        }

        .card .top-left { top: 8px; left: 8px; }
        .card .bottom-right { bottom: 8px; right: 8px; transform: rotate(180deg); }

        .card-back {
            background: linear-gradient(135deg, #1a1f3a 0%, #0a0e27 100%);
            border: 2px solid #2979ff;
            color: white;
            display: flex; 
            justify-content: center; 
            align-items: center;
            overflow: hidden;
        }

        .card-back::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(41, 121, 255, 0.1) 10px,
                rgba(41, 121, 255, 0.1) 20px
            );
            animation: cardBackPattern 20s linear infinite;
        }

        @keyframes cardBackPattern {
            0% { transform: translate(0, 0); }
            100% { transform: translate(20px, 20px); }
        }

        .card-back-text {
            font-family: 'Orbitron', monospace;
            font-size: 32px; 
            font-weight: 900;
            background: linear-gradient(45deg, #2979ff, #00e676, #ffc107, #ff1744);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(41, 121, 255, 0.5);
            z-index: 1;
        }

        .card-red { 
            background: linear-gradient(135deg, #ff1744 0%, #d50000 100%); 
            color: white; 
        }
        .card-yellow { 
            background: linear-gradient(135deg, #ffc107 0%, #ff6f00 100%); 
            color: #1a1f3a; 
        }
        .card-green { 
            background: linear-gradient(135deg, #00e676 0%, #00c853 100%); 
            color: white; 
        }
        .card-blue { 
            background: linear-gradient(135deg, #2979ff 0%, #0d47a1 100%); 
            color: white; 
        }
        .card-black { 
            background: linear-gradient(135deg, #424242 0%, #000000 100%); 
            color: white; 
        }

        .wild-center-icon {
            width: 70%; 
            height: 70%; 
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                #ff1744 0deg,
                #ffc107 90deg,
                #00e676 180deg,
                #2979ff 270deg,
                #ff1744 360deg
            );
            display: flex; 
            align-items: center; 
            justify-content: center;
            animation: wildRotate 3s linear infinite;
            box-shadow: 
                0 0 20px rgba(255,255,255,0.5),
                inset 0 0 20px rgba(0,0,0,0.3);
        }

        @keyframes wildRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .wild-center-icon .value-center { 
            font-size: 28px; 
            color: white; 
            text-shadow: 2px 2px 4px black;
            animation: wildRotate 3s linear infinite reverse;
        }

        #game-board { 
            background: transparent;
        }

        .player-area {
            padding: 16px;
            border-radius: 16px;
            background: rgba(26, 31, 58, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 180px;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-area.active-turn { 
            border: 2px solid var(--accent-blue);
            background: rgba(41, 121, 255, 0.1);
            box-shadow: 
                0 0 30px rgba(41, 121, 255, 0.5),
                inset 0 0 20px rgba(41, 121, 255, 0.2);
            animation: turnPulse 2s ease-in-out infinite;
        }

        @keyframes turnPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .player-area.current-player {
            border: 2px solid var(--accent-green);
            background: rgba(0, 230, 118, 0.1);
        }

        .player-hand {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: flex-start;
            width: 100%;
            flex-grow: 1;
            min-height: 0;
            overflow: visible;
            gap: 2px;
        }
        
        .other-player-hand {
            max-height: 170px;
            overflow: hidden;
        }
        
        .other-player-hand .card { 
            width: 50px; 
            height: 80px; 
            font-size: 10px; 
            margin: 3px; 
            padding: 4px; 
        }

        .other-player-hand .card .value-center { font-size: 24px; }
        .other-player-hand .card .corner-value { font-size: 10px; top:4px; left:4px;}
        .other-player-hand .card .bottom-right {bottom:4px; right:4px;}
        .other-player-hand .card-back .card-back-text { font-size: 18px; }
        .other-player-hand .card:hover { transform: scale(1.05); }

        .discard-pile .card, .draw-pile .card { cursor: default; }
        .discard-pile .card:hover, .draw-pile .card:hover { 
            transform: none; 
            box-shadow: var(--card-shadow); 
        }

        .playable { 
            animation: playableGlow 1.5s ease-in-out infinite;
            cursor: pointer !important;
        }

        @keyframes playableGlow {
            0%, 100% { 
                box-shadow: 
                    0 0 20px var(--accent-yellow),
                    0 0 40px var(--accent-yellow),
                    inset 0 0 20px rgba(255, 193, 7, 0.3);
                border-color: var(--accent-yellow);
            }
            50% { 
                box-shadow: 
                    0 0 30px var(--accent-yellow),
                    0 0 60px var(--accent-yellow),
                    inset 0 0 30px rgba(255, 193, 7, 0.4);
                border-color: #ffeb3b;
            }
        }

        #color-picker-modal {
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            background: rgba(26, 31, 58, 0.95);
            backdrop-filter: blur(20px);
            padding: 40px; 
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .color-button {
            width: 80px; 
            height: 80px; 
            border-radius: 50%; 
            margin: 10px; 
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .color-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transform: translate(-50%, -50%);
            transition: all 0.6s;
        }

        .color-button:hover::before {
            width: 100%;
            height: 100%;
        }

        .color-button:hover { 
            transform: scale(1.15) rotate(5deg); 
            box-shadow: 0 0 30px currentColor;
            border-color: currentColor;
        }

        .current-color-indicator {
            width: 32px; 
            height: 32px; 
            border-radius: 50%; 
            display: inline-block;
            margin-left: 12px; 
            vertical-align: middle; 
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 
                0 2px 10px rgba(0,0,0,0.3),
                inset 0 2px 4px rgba(255,255,255,0.2);
        }

        @keyframes cardDropToDiscardAnimation {
            0% { 
                transform: translateY(-100px) rotate(-20deg) scale(0.7); 
                opacity: 0; 
            }
            50% { 
                transform: translateY(20px) rotate(5deg) scale(1.1); 
            }
            100% { 
                transform: translateY(0) rotate(0deg) scale(1); 
                opacity: 1; 
            }
        }

        .card-animate-to-discard { 
            animation: cardDropToDiscardAnimation 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); 
            position: relative; 
            z-index: 10; 
        }

        #uno-callout, #win-callout {
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%) scale(0);
            padding: 30px 60px; 
            font-size: 4rem; 
            font-weight: 900;
            border-radius: 20px; 
            z-index: 3000; 
            text-align: center;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
            animation: calloutAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        @keyframes calloutAppear {
            to {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        #uno-callout {
            background: linear-gradient(135deg, var(--accent-yellow) 0%, var(--accent-red) 100%);
            color: white;
            box-shadow: 
                0 0 60px rgba(255, 193, 7, 0.8),
                inset 0 0 20px rgba(255,255,255,0.3);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        #win-callout {
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-blue) 100%);
            color: white;
            box-shadow: 
                0 0 60px rgba(0, 230, 118, 0.8),
                inset 0 0 20px rgba(255,255,255,0.3);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        .room-code {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 0.3em;
            color: var(--accent-blue);
            background: rgba(41, 121, 255, 0.1);
            padding: 12px 24px;
            border-radius: 12px;
            border: 2px solid var(--accent-blue);
            box-shadow: 
                0 0 20px rgba(41, 121, 255, 0.3),
                inset 0 0 20px rgba(41, 121, 255, 0.1);
        }

        #stack-penalty-display {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-red);
            background: rgba(255, 23, 68, 0.1);
            padding: 8px 20px;
            border-radius: 20px;
            margin-top: 8px;
            display: none;
            border: 1px solid var(--accent-red);
            animation: stackPulse 1s ease-in-out infinite;
        }
        
        @keyframes stackPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 10px rgba(255, 23, 68, 0.5);
            }
            50% { 
                transform: scale(1.05); 
                box-shadow: 0 0 20px rgba(255, 23, 68, 0.8);
            }
        }

        #my-player-area {
            min-height: 380px;
            margin-bottom: 20px;
            background: rgba(26, 31, 58, 0.8);
            overflow: visible;
        }
        
        #my-hand {
            overflow: visible;
            padding: 10px 0;
        }

        #game-over-screen {
            backdrop-filter: blur(10px);
            background: rgba(10, 14, 39, 0.9);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-blue) 0%, #1565c0 100%);
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            padding: 12px 32px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 
                0 4px 20px rgba(41, 121, 255, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 30px rgba(41, 121, 255, 0.5),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            padding: 12px 32px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent-red) 0%, #c62828 100%);
            color: white;
            font-weight: 600;
            padding: 10px 24px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(255, 23, 68, 0.5);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--accent-green) 0%, #00a152 100%);
            color: white;
            font-weight: 600;
            padding: 12px 32px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 230, 118, 0.5);
        }

        .input-field {
            width: 100%;
            padding: 14px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: white;
            font-size: 1.1rem;
            font-weight: 500;
            transition: all 0.3s;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-blue);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 20px rgba(41, 121, 255, 0.3);
        }

        .input-field::placeholder {
            color: var(--text-secondary);
        }

        #table-area {
            background: radial-gradient(ellipse at center, rgba(0, 230, 118, 0.1) 0%, transparent 70%);
            border: 2px solid rgba(0, 230, 118, 0.2);
            position: relative;
            overflow: hidden;
        }

        #table-area::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                var(--accent-green), 
                transparent, 
                var(--accent-blue), 
                transparent, 
                var(--accent-green)
            );
            opacity: 0.3;
            animation: tableBorder 8s linear infinite;
            border-radius: 20px;
        }

        @keyframes tableBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #center-info-area {
            background: rgba(26, 31, 58, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1;
        }

        #turn-timer-display {
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            color: var(--accent-yellow);
        }

        .player-list-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s;
        }

        .player-list-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        #final-rankings > div {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        #final-rankings > div:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .modal-content {
            background: rgba(26, 31, 58, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        h1, h2, h3 {
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .turn-notification {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-purple) 100%);
            color: white;
            padding: 20px 60px;
            border-radius: 50px;
            font-size: 2rem;
            font-weight: 900;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            box-shadow: 
                0 10px 40px rgba(41, 121, 255, 0.6),
                inset 0 2px 4px rgba(255,255,255,0.3);
            animation: turnNotify 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 2500;
        }
        
        @keyframes turnNotify {
            0% {
                transform: translateX(-50%) translateY(-100px) scale(0);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) translateY(20px) scale(1.1);
            }
            100% {
                transform: translateX(-50%) translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        .logo-text {
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(45deg, 
                var(--accent-red), 
                var(--accent-yellow), 
                var(--accent-green), 
                var(--accent-blue)
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(255,255,255,0.3);
            animation: logoGlow 3s ease-in-out infinite;
        }

        @keyframes logoGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-2">
    <div class="game-container w-full h-full flex items-center justify-center">

        <div id="room-setup" class="fixed inset-0 flex items-center justify-center z-50">
            <div class="modal-content p-10 max-w-md w-full">
                <h1 class="logo-text text-center mb-10">UNO</h1>
                
                <div class="mb-8">
                    <input type="text" id="player-name" placeholder="輸入您的名字" 
                        class="input-field">
                </div>

                <div class="space-y-4">
                    <button id="create-room-btn" class="btn-primary w-full">
                        創建房間
                    </button>
                    
                    <div class="flex space-x-3">
                        <input type="text" id="room-code-input" placeholder="輸入房間代碼" maxlength="6"
                            class="input-field flex-1 text-center uppercase tracking-widest">
                        <button id="join-room-btn" class="btn-success">
                            加入房間
                        </button>
                    </div>
                </div>
                
                <div id="error-message" class="mt-6 text-red-400 text-center hidden font-semibold"></div>
            </div>
        </div>

        <div id="waiting-room" class="fixed inset-0 flex items-center justify-center z-50 hidden">
            <div class="modal-content p-10 max-w-md w-full">
                <h2 class="neon-text text-3xl text-center mb-8">等待玩家加入</h2>
                
                <div class="text-center mb-8">
                    <p class="text-secondary mb-3">房間代碼</p>
                    <div id="room-code-display" class="room-code"></div>
                    <p class="text-sm text-secondary mt-3">支援 1-4 位玩家，不足 4 人會有電腦補位</p>
                </div>
                
                <div id="players-list" class="space-y-3 mb-8">
                </div>
                
                <button id="ready-btn" class="btn-success w-full mb-3">
                    準備開始
                </button>
                
                <button id="leave-room-btn" class="btn-danger w-full">
                    離開房間
                </button>
            </div>
        </div>

        <div id="game-board" class="w-full max-w-7xl mx-auto p-4 hidden flex flex-col justify-between h-[95vh]">
            <div id="other-players-container" class="grid gap-4">
            </div>

            <div id="table-area" class="flex justify-around items-center my-6 p-8 rounded-3xl shadow-2xl relative">
                
                <div id="draw-pile-container" class="text-center">
                    <h3 class="text-secondary font-semibold text-lg mb-2">抽牌堆</h3>
                    <div id="draw-pile" class="draw-pile"></div>
                    <p class="text-secondary text-sm mt-2">(<span id="draw-pile-count">0</span> 張)</p>
                </div>

                <div id="discard-pile-container" class="text-center">
                    <h3 class="text-secondary font-semibold text-lg mb-2">棄牌堆</h3>
                    <div id="discard-pile" class="discard-pile"></div>
                </div>

                <div id="center-info-area" class="flex flex-col items-center justify-center text-center mx-6 px-8 py-6 rounded-2xl shadow-xl">
                    <div id="active-player-display" class="text-2xl font-bold mb-3 neon-text">等待開始</div>
                    <div id="turn-timer-display" class="text-lg mb-3">思考時間: 10s</div>
                    <div id="stack-penalty-display">累積懲罰: +0</div>
                    <div id="current-color-display" class="mt-3 flex items-center">
                        <span class="font-semibold text-secondary">當前顏色:</span>
                        <span id="current-color-indicator" class="current-color-indicator"></span>
                    </div>
                </div>

            </div>

            <div id="my-player-area" class="player-area current-player mx-auto p-6 w-full">
                <h2 class="text-2xl font-bold mb-4 neon-text">
                    <span id="my-name">我</span> (<span id="my-card-count">0</span>)
                </h2>
                <div id="my-hand" class="player-hand"></div>
            </div>
        </div>

        <div id="color-picker-modal" class="hidden">
            <h3 class="neon-text text-2xl text-center mb-8">選擇顏色</h3>
            <div class="flex justify-center">
                <button class="color-button" data-color="red" style="background: linear-gradient(135deg, #ff1744, #d50000);"></button>
                <button class="color-button" data-color="yellow" style="background: linear-gradient(135deg, #ffc107, #ff6f00);"></button>
                <button class="color-button" data-color="green" style="background: linear-gradient(135deg, #00e676, #00c853);"></button>
                <button class="color-button" data-color="blue" style="background: linear-gradient(135deg, #2979ff, #0d47a1);"></button>
            </div>
        </div>

        <div id="uno-callout" class="hidden">UNO!</div>

        <div id="win-callout" class="hidden">獲勝！</div>

        <div id="game-over-screen" class="fixed inset-0 flex items-center justify-center z-50 hidden">
            <div class="modal-content p-10 max-w-lg w-full">
                <h2 id="game-over-title" class="neon-text text-4xl text-center mb-8">遊戲結束</h2>
                
                <div id="game-over-message" class="text-2xl text-center mb-10 font-semibold"></div>
                
                <div id="final-rankings" class="mb-10 space-y-3"></div>
                
                <div id="rematch-votes" class="mb-8 hidden">
                    <h3 class="text-xl font-semibold mb-4 text-center">同意再來一局</h3>
                    <div id="vote-list" class="space-y-2"></div>
                    <div class="text-center mt-4 text-secondary">
                        <span id="vote-count">0</span> / <span id="total-players">0</span> 位玩家同意
                    </div>
                </div>
                
                <div class="space-y-3">
                    <button id="rematch-btn" class="btn-success w-full">
                        再來一局
                    </button>
                    
                    <button id="leave-game-btn" class="btn-secondary w-full">
                        離開遊戲
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        const ICONS = {
            skip: `<svg viewBox="0 0 100 100" class="action-icon"><circle cx="50" cy="50" r="40" stroke-width="10" stroke="currentColor" fill="none"/><line x1="25" y1="25" x2="75" y2="75" stroke-width="12" stroke="currentColor"/></svg>`,
            reverse: `<svg viewBox="0 0 100 100" class="action-icon"><path d="M 25 50 A 25 25 0 1 1 75 50 L 75 70 L 90 50 L 75 30 L 75 50" stroke-width="10" stroke="currentColor" fill="none"/><path d="M 75 50 A 25 25 0 1 1 25 50 L 25 30 L 10 50 L 25 70 L 25 50" stroke-width="10" stroke="currentColor" fill="none" transform="rotate(180 50 50)"/></svg>`,
            drawTwo: `<span class="value-center" style="font-size:36px; line-height:1;">+2</span>`,
            wild: `<span class="value-center" style="font-size:36px; line-height:1;">W</span>`,
            wildDrawFour: `<span class="value-center" style="font-size:30px; line-height:1;">W+4</span>`
        };

        class MultiplayerUnoGame {
            constructor() {
                this.socket = io();
                this.myPlayerId = null;
                this.gameState = null;
                this.roomId = null;
                this.canPlayDrawnCard = false;
                this.turnTimer = null;
                this.turnTimerInterval = null;
                this.setupSocketListeners();
                this.setupUIListeners();
            }

            setupSocketListeners() {
                this.socket.on('roomCreated', ({ roomId, player }) => {
                    this.roomId = roomId;
                    this.myPlayerId = player.id;
                    this.showWaitingRoom(roomId);
                });

                this.socket.on('joinSuccess', ({ roomId, player }) => {
                    this.roomId = roomId;
                    this.myPlayerId = player.id;
                    this.showWaitingRoom(roomId);
                });

                this.socket.on('joinError', (error) => {
                    this.showError(error);
                });

                this.socket.on('roomUpdate', ({ players, canStart }) => {
                    this.updatePlayersList(players);
                });

                this.socket.on('gameStart', ({ playerId, gameState }) => {
                    this.myPlayerId = playerId;
                    this.gameState = gameState;
                    this.canPlayDrawnCard = false;
                    this.showGameBoard();
                    this.renderGameState();
                    this.startTurnTimer();
                });

                this.socket.on('gameUpdate', ({ gameState, lastMove, result }) => {
                    const previousPlayerIndex = this.gameState ? this.gameState.currentPlayerIndex : -1;
                    const previousPlayerId = this.gameState ? this.gameState.players[previousPlayerIndex]?.id : null;
                    
                    this.gameState = gameState;
                    
                    if (previousPlayerIndex !== gameState.currentPlayerIndex) {
                        this.canPlayDrawnCard = false;
                    }
                    
                    this.renderGameState();
                    
                    if (result && result.skippedPlayerId) {
                        const skippedPlayer = this.gameState.players.find(p => p.id === result.skippedPlayerId);
                        if (skippedPlayer) {
                            setTimeout(() => this.showSkipMessage(skippedPlayer.name), 500);
                        }
                    }
                    
                    if (result && result.timeout && result.forceEndTurn) {
                        this.canPlayDrawnCard = false;
                        if (lastMove.playerId === this.myPlayerId || previousPlayerId === this.myPlayerId) {
                            this.showTimeoutMessage();
                        }
                        this.startTurnTimer();
                        return;
                    }
                    
                    if (result && result.timeout && lastMove && lastMove.type === 'drawCard') {
                        this.canPlayDrawnCard = false;
                        if (lastMove.playerId === this.myPlayerId) {
                            this.showTimeoutMessage();
                        }
                        return;
                    }
                    
                    if (lastMove && lastMove.type === 'drawCard' && lastMove.playerId === this.myPlayerId && result.canPlayDrawnCard) {
                        this.canPlayDrawnCard = true;
                        if (result.remainingTime !== undefined) {
                            this.startTurnTimer(result.remainingTime);
                        }
                        return;
                    }
                    
                    if (result.needColorSelection && lastMove.playerId === this.myPlayerId) {
                        this.showColorPicker();
                        return;
                    }
                    
                    if (result.newUnoPlayer) {
                        const unoPlayer = this.gameState.players.find(p => p.id === result.newUnoPlayer);
                        if (unoPlayer) {
                            this.showUnoCallout(unoPlayer.name);
                        }
                    }
                    
                    this.startTurnTimer();
                });

                this.socket.on('gameOver', ({ winner, reason }) => {
                    this.clearTurnTimer();
                    
                    if (winner) {
                        this.showWinCallout(winner);
                    } else if (reason) {
                        this.showWinCallout(reason, true);
                    }
                    
                    setTimeout(() => {
                        this.showGameOverScreen(winner, reason);
                    }, 2000);
                });

                this.socket.on('rematchUpdate', ({ votes, totalPlayers, allVoted }) => {
                    this.updateRematchVotes(votes, totalPlayers);
                    
                    if (allVoted) {
                        document.getElementById('game-over-message').innerHTML = 
                            '<span class="text-green-400 font-bold">所有玩家同意！準備開始新遊戲...</span>';
                    }
                });

                this.socket.on('returnToWaitingRoom', ({ players }) => {
                    document.getElementById('game-over-screen').classList.add('hidden');
                    document.getElementById('game-board').classList.add('hidden');
                    document.getElementById('waiting-room').classList.remove('hidden');
                    this.updatePlayersList(players);
                    this.gameState = null;
                    this.canPlayDrawnCard = false;
                });

                this.socket.on('moveError', (error) => {
                    console.error('移動錯誤:', error);
                });

                this.socket.on('playerDisconnected', ({ playerId }) => {
                });
            }

            setupUIListeners() {
                document.getElementById('create-room-btn').addEventListener('click', () => {
                    const playerName = document.getElementById('player-name').value.trim() || '玩家';
                    this.socket.emit('createRoom', playerName);
                });

                document.getElementById('join-room-btn').addEventListener('click', () => {
                    const roomId = document.getElementById('room-code-input').value.trim().toUpperCase();
                    const playerName = document.getElementById('player-name').value.trim() || '玩家';
                    
                    if (roomId.length !== 6) {
                        this.showError('請輸入6位房間代碼');
                        return;
                    }
                    
                    this.socket.emit('joinRoom', { roomId, playerName });
                });

                document.getElementById('ready-btn').addEventListener('click', () => {
                    this.socket.emit('playerReady');
                    document.getElementById('ready-btn').disabled = true;
                    document.getElementById('ready-btn').textContent = '等待其他玩家...';
                });

                document.getElementById('leave-room-btn').addEventListener('click', () => {
                    location.reload();
                });

                document.querySelectorAll('#color-picker-modal .color-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const color = e.target.dataset.color;
                        this.clearTurnTimer();
                        this.socket.emit('gameMove', { type: 'selectColor', color });
                        this.hideColorPicker();
                    });
                });

                document.getElementById('rematch-btn').addEventListener('click', () => {
                    this.socket.emit('requestRematch');
                    document.getElementById('rematch-btn').disabled = true;
                    document.getElementById('rematch-btn').textContent = '等待其他玩家...';
                    document.getElementById('rematch-votes').classList.remove('hidden');
                });

                document.getElementById('leave-game-btn').addEventListener('click', () => {
                    location.reload();
                });
            }

            showError(message) {
                const errorEl = document.getElementById('error-message');
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
                setTimeout(() => errorEl.classList.add('hidden'), 3000);
            }

            showWaitingRoom(roomId) {
                document.getElementById('room-setup').classList.add('hidden');
                document.getElementById('waiting-room').classList.remove('hidden');
                document.getElementById('room-code-display').textContent = roomId;
            }

            showGameBoard() {
                document.getElementById('waiting-room').classList.add('hidden');
                document.getElementById('game-board').classList.remove('hidden');
            }

            startTurnTimer(initialTime = 15) {
                this.clearTurnTimer();
                
                if (!this.gameState) return;
                
                const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];
                const isMyTurn = currentPlayer.id === this.myPlayerId;
                
                // 如果輪到玩家，顯示提示
                if (isMyTurn && !currentPlayer.isComputer) {
                    this.showTurnNotification();
                }
                
                if (currentPlayer.isComputer) {
                    document.getElementById('turn-timer-display').textContent = '電腦思考中...';
                    return;
                }
                
                let timeRemaining = initialTime;
                document.getElementById('turn-timer-display').textContent = `思考時間: ${timeRemaining}s`;
                document.getElementById('turn-timer-display').style.color = '';
                
                this.turnTimerInterval = setInterval(() => {
                    timeRemaining--;
                    if (timeRemaining > 0) {
                        document.getElementById('turn-timer-display').textContent = `思考時間: ${timeRemaining}s`;
                        if (timeRemaining <= 3) {
                            document.getElementById('turn-timer-display').style.color = 'var(--accent-red)';
                        }
                    } else if (timeRemaining === 0) {
                        document.getElementById('turn-timer-display').textContent = '超時！';
                        document.getElementById('turn-timer-display').style.color = 'var(--accent-red)';
                    } else {
                        this.clearTurnTimer();
                    }
                }, 1000);
            }

            clearTurnTimer() {
                if (this.turnTimerInterval) {
                    clearInterval(this.turnTimerInterval);
                    this.turnTimerInterval = null;
                }
            }

            updatePlayersList(players) {
                const listEl = document.getElementById('players-list');
                listEl.innerHTML = players.map(p => `
                    <div class="player-list-item flex items-center justify-between">
                        <span class="font-semibold text-lg">${p.name}</span>
                        <span class="text-sm ${p.ready ? 'text-green-400' : 'text-secondary'}">
                            ${p.ready ? '✓ 已準備' : '未準備'}
                        </span>
                    </div>
                `).join('');
                
                const readyBtn = document.getElementById('ready-btn');
                const myPlayer = players.find(p => p.socketId === this.socket.id);
                
                readyBtn.disabled = myPlayer ? myPlayer.ready : false;
                readyBtn.textContent = (myPlayer && myPlayer.ready) ? '等待其他玩家...' : '準備開始';
                
                const canStart = players.length >= 1 && players.length <= 4 && players.every(p => p.ready);
                if (canStart) {
                    readyBtn.textContent = '遊戲即將開始...';
                    readyBtn.disabled = true;
                }
            }

            renderGameState() {
                if (!this.gameState) return;

                this.renderOtherPlayers();
                this.renderMyHand();
                this.renderDiscardPile();
                this.renderDrawPile();
                this.updateGameInfo();
                this.highlightCurrentPlayer();
            }

            renderOtherPlayers() {
                const container = document.getElementById('other-players-container');
                container.innerHTML = '';
                
                const otherPlayers = this.gameState.players.filter(p => p.id !== this.myPlayerId);
                
                const gridClass = {
                    1: 'grid-cols-1 justify-items-center',
                    2: 'grid-cols-2', 
                    3: 'grid-cols-3'
                }[otherPlayers.length] || 'grid-cols-3';
                
                container.className = `grid ${gridClass} gap-4`;
                
                otherPlayers.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-area';
                    playerDiv.id = `player-${player.id}`;
                    
                    const cardCount = player.handCount || player.hand.length;
                    const maxCardsToShow = 14;
                    const cardsToDisplay = Math.min(cardCount, maxCardsToShow);
                    
                    playerDiv.innerHTML = `
                        <h3 class="text-base font-bold mb-2 neon-text text-sm">
                            ${player.name} (${cardCount})
                        </h3>
                        <div class="player-hand other-player-hand">
                            ${Array(cardsToDisplay).fill().map(() => this.renderCard({}, false, true).outerHTML).join('')}
                        </div>
                    `;
                    
                    container.appendChild(playerDiv);
                });
            }

            renderMyHand() {
                const myPlayer = this.gameState.players.find(p => p.id === this.myPlayerId);
                if (!myPlayer) return;

                document.getElementById('my-name').textContent = myPlayer.name;
                document.getElementById('my-card-count').textContent = myPlayer.hand.length;
                
                const handEl = document.getElementById('my-hand');
                handEl.innerHTML = '';
                
                const topCard = this.gameState.discardPile[this.gameState.discardPile.length - 1];
                const isMyTurn = this.gameState.currentPlayerIndex === this.gameState.players.findIndex(p => p.id === this.myPlayerId);
                
                myPlayer.hand.forEach((card, index) => {
                    const isPlayableOnMyTurn = isMyTurn && this.isCardPlayable(card, topCard, myPlayer.hand.length);
                    const canPlayTheDrawnCard = this.canPlayDrawnCard && index === myPlayer.hand.length - 1;

                    const cardEl = this.renderCard(card, true, false);
                    
                    if (isPlayableOnMyTurn || canPlayTheDrawnCard) {
                        cardEl.classList.add('playable');
                        cardEl.addEventListener('click', () => {
                            this.clearTurnTimer();
                            this.canPlayDrawnCard = false;
                            this.socket.emit('gameMove', { type: 'playCard', cardIndex: index });
                        });
                    } else {
                        cardEl.style.cursor = 'default';
                        cardEl.style.transform = '';
                    }
                    
                    handEl.appendChild(cardEl);
                });
            }

            renderDiscardPile() {
                const discardEl = document.getElementById('discard-pile');
                discardEl.innerHTML = '';
                
                if (this.gameState.discardPile.length > 0) {
                    const topCard = this.gameState.discardPile[this.gameState.discardPile.length - 1];
                    const cardEl = this.renderCard(topCard, true, false);
                    cardEl.style.cursor = 'default';
                    discardEl.appendChild(cardEl);
                }
            }

            renderDrawPile() {
                const drawEl = document.getElementById('draw-pile');
                drawEl.innerHTML = '';
                
                const cardBack = this.renderCard({}, false, false);
                const isMyTurn = this.gameState.currentPlayerIndex === this.gameState.players.findIndex(p => p.id === this.myPlayerId);
                
                if (isMyTurn && !this.gameState.playerHasDrawnThisTurn) {
                    cardBack.style.cursor = 'pointer';
                    cardBack.addEventListener('click', () => {
                        this.clearTurnTimer();
                        this.socket.emit('gameMove', { type: 'drawCard' });
                    });
                } else {
                    cardBack.style.cursor = 'default';
                }
                
                drawEl.appendChild(cardBack);
                document.getElementById('draw-pile-count').textContent = this.gameState.deckCount;
            }

            updateGameInfo() {
                const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];
                document.getElementById('active-player-display').textContent = `${currentPlayer.name} 的回合`;
                
                const stackEl = document.getElementById('stack-penalty-display');
                if (this.gameState.isStackActive) {
                    stackEl.textContent = `累積懲罰: +${this.gameState.stackPenalty}`;
                    stackEl.style.display = 'inline-block';
                } else {
                    stackEl.style.display = 'none';
                }
                
                const colorEl = document.getElementById('current-color-indicator');
                if (this.gameState.currentColorInPlay) {
                    colorEl.style.backgroundColor = this.getColorCode(this.gameState.currentColorInPlay);
                } else {
                    const topCard = this.gameState.discardPile[this.gameState.discardPile.length - 1];
                    colorEl.style.backgroundColor = topCard ? this.getColorCode(topCard.color) : '#424242';
                }
            }

            highlightCurrentPlayer() {
                document.querySelectorAll('.player-area').forEach(el => {
                    el.classList.remove('active-turn');
                });
                
                const myPlayerArea = document.getElementById('my-player-area');
                myPlayerArea.classList.remove('active-turn');
                myPlayerArea.classList.add('current-player');

                const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];
                const targetEl = (currentPlayer.id === this.myPlayerId) 
                    ? myPlayerArea 
                    : document.getElementById(`player-${currentPlayer.id}`);
                
                if (targetEl) {
                     targetEl.classList.add('active-turn');
                }
            }

            renderCard(card, showFace = true, isSmall = false) {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                
                if (!showFace || !card.color) {
                    cardDiv.classList.add('card-back');
                    cardDiv.innerHTML = `<span class="card-back-text">UNO</span>`;
                    return cardDiv;
                }
                
                cardDiv.classList.add(`card-${card.color}`);
                
                let centerContentHTML = '';
                let cornerDisplay = card.display;
                
                switch(card.type) {
                    case 'number':
                        centerContentHTML = `<span class="value-center">${card.value}</span>`;
                        break;
                    case 'skip':
                        centerContentHTML = ICONS.skip;
                        if (card.color === 'yellow') centerContentHTML = centerContentHTML.replace('stroke="currentColor"', 'stroke="#1a1f3a"');
                        break;
                    case 'reverse':
                        centerContentHTML = ICONS.reverse;
                        if (card.color === 'yellow') centerContentHTML = centerContentHTML.replace('stroke="currentColor"', 'stroke="#1a1f3a"');
                        break;
                    case 'drawTwo':
                        centerContentHTML = ICONS.drawTwo;
                        break;
                    case 'wild':
                        centerContentHTML = `<div class="wild-center-icon"><span class="value-center">W</span></div>`;
                        cornerDisplay = 'W';
                        break;
                    case 'wildDrawFour':
                        centerContentHTML = `<div class="wild-center-icon"><span class="value-center">+4</span></div>`;
                        cornerDisplay = 'W+4';
                        break;
                }
                
                cardDiv.innerHTML = `
                    <span class="corner-value top-left">${cornerDisplay}</span>
                    ${centerContentHTML}
                    <span class="corner-value bottom-right">${cornerDisplay}</span>
                `;
                
                return cardDiv;
            }

            isCardPlayable(card, topCard, handSize) {
                if (!topCard) return true;

                if (this.gameState.playerHasDrawnThisTurn) {
                     const myPlayer = this.gameState.players.find(p => p.id === this.myPlayerId);
                     const drawnCard = myPlayer.hand[myPlayer.hand.length - 1];
                     if (card.color !== drawnCard.color || card.value !== drawnCard.value) return false;
                }

                if (handSize === 1 && card.type !== 'number' && card.type !== 'wild') {
                    return false;
                }
                
                if (this.gameState.isStackActive) {
                    if (this.gameState.stackType === 'drawTwo' && card.type === 'drawTwo') return true;
                    if (this.gameState.stackType === 'wildDrawFour' && card.type === 'wildDrawFour') return true;
                    if (this.gameState.stackType === 'skip' && card.type === 'skip' && card.color === topCard.color) return true;
                    return false;
                }
                
                if (card.color === 'black') return true;
                const effectiveColor = this.gameState.currentColorInPlay || topCard.color;
                return card.color === effectiveColor || card.value === topCard.value;
            }

            showColorPicker() {
                document.getElementById('color-picker-modal').classList.remove('hidden');
            }

            hideColorPicker() {
                document.getElementById('color-picker-modal').classList.add('hidden');
            }

            getColorCode(color) {
                const colors = {
                    'red': '#ff1744', 
                    'yellow': '#ffc107', 
                    'green': '#00e676',
                    'blue': '#2979ff', 
                    'black': '#424242'
                };
                return colors[color] || '#424242';
            }

            showUnoCallout(playerName) {
                const callout = document.getElementById('uno-callout');
                callout.textContent = `${playerName} UNO!`;
                callout.classList.remove('hidden');
                setTimeout(() => callout.classList.add('hidden'), 1500);
            }

            showSkipMessage(playerName) {
                const msgDiv = document.createElement('div');
                msgDiv.style.cssText = `
                    position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #ff6f00 0%, #ff9800 100%); 
                    color: white; padding: 30px 50px;
                    border-radius: 16px; font-size: 2rem; font-weight: 900;
                    z-index: 2000; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                    animation: skipBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                    font-family: 'Orbitron', monospace;
                    text-transform: uppercase;
                    letter-spacing: 0.1em;
                `;
                msgDiv.innerHTML = `⛔ ${playerName} 被跳過！`;
                document.body.appendChild(msgDiv);
                
                if (!document.getElementById('skip-animation-style')) {
                    const style = document.createElement('style');
                    style.id = 'skip-animation-style';
                    style.textContent = `@keyframes skipBounce { 
                        0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; } 
                        50% { transform: translate(-50%, -50%) scale(1.2) rotate(10deg); } 
                        100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } 
                    }`;
                    document.head.appendChild(style);
                }
                
                setTimeout(() => {
                    msgDiv.style.animation = 'skipBounce 0.4s ease-in reverse';
                    setTimeout(() => msgDiv.remove(), 400);
                }, 1500);
            }

            showTimeoutMessage() {
                const msgDiv = document.createElement('div');
                msgDiv.style.cssText = `
                    position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #c62828 0%, #f44336 100%); 
                    color: white; padding: 30px 50px;
                    border-radius: 16px; font-size: 2rem; font-weight: 900;
                    z-index: 2000; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                    animation: timeoutShake 0.5s ease-out;
                    font-family: 'Orbitron', monospace;
                    text-transform: uppercase;
                    letter-spacing: 0.1em;
                `;
                msgDiv.textContent = '⏰ 超時！回合結束';
                document.body.appendChild(msgDiv);
                
                if (!document.getElementById('timeout-animation-style')) {
                    const style = document.createElement('style');
                    style.id = 'timeout-animation-style';
                    style.textContent = `@keyframes timeoutShake { 
                        0%, 100% { transform: translate(-50%, -50%); } 
                        10% { transform: translate(-48%, -50%); }
                        20% { transform: translate(-52%, -50%); }
                        30% { transform: translate(-48%, -50%); }
                        40% { transform: translate(-52%, -50%); }
                        50% { transform: translate(-50%, -50%); }
                    }`;
                    document.head.appendChild(style);
                }
                
                setTimeout(() => {
                    msgDiv.style.opacity = '0';
                    msgDiv.style.transition = 'opacity 0.4s';
                    setTimeout(() => msgDiv.remove(), 400);
                }, 1700);
            }

            showGameOverScreen(winner, reason) {
                const titleEl = document.getElementById('game-over-title');
                const messageEl = document.getElementById('game-over-message');
                const rankingsEl = document.getElementById('final-rankings');
                
                if (winner) {
                    titleEl.textContent = '🏆 遊戲結束 🏆';
                    messageEl.innerHTML = `<span class="text-3xl font-bold text-green-400">${winner} 獲勝！</span>`;
                } else if (reason) {
                    titleEl.textContent = '遊戲結束';
                    messageEl.innerHTML = `<span class="text-2xl text-secondary">${reason}</span>`;
                }
                
                if (this.gameState) {
                    const rankings = [...this.gameState.players]
                        .filter(p => !p.isComputer)
                        .sort((a, b) => (a.hand.length || 0) - (b.hand.length || 0));
                    
                    rankingsEl.innerHTML = '<h3 class="text-xl font-bold mb-4 text-center text-secondary">最終排名</h3>' +
                        rankings.map((player, index) => {
                            const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '👤';
                            const isMe = player.id === this.myPlayerId;
                            const bgColor = index === 0 ? 'rgba(0, 230, 118, 0.1)' : 
                                          index === 1 ? 'rgba(41, 121, 255, 0.1)' : 
                                          index === 2 ? 'rgba(255, 193, 7, 0.1)' : 
                                          'rgba(255, 255, 255, 0.05)';
                            return `
                                <div class="flex justify-between items-center p-4 rounded-lg" 
                                     style="background: ${bgColor}; border: 1px solid rgba(255,255,255,0.1);">
                                    <span class="font-bold text-xl">
                                        ${medal} ${player.name} ${isMe ? '(你)' : ''}
                                    </span>
                                    <span class="text-secondary">剩餘 ${player.handCount || 0} 張牌</span>
                                </div>
                            `;
                        }).join('');
                }
                
                document.getElementById('rematch-btn').disabled = false;
                document.getElementById('rematch-btn').textContent = '再來一局';
                document.getElementById('rematch-votes').classList.add('hidden');
                document.getElementById('vote-list').innerHTML = '';
                document.getElementById('game-over-screen').classList.remove('hidden');
            }

            updateRematchVotes(votes, totalPlayers) {
                const voteListEl = document.getElementById('vote-list');
                const voteCountEl = document.getElementById('vote-count');
                const totalPlayersEl = document.getElementById('total-players');
                
                voteCountEl.textContent = votes.length;
                totalPlayersEl.textContent = totalPlayers;
                
                if (this.gameState) {
                    const votedPlayers = votes.map(playerId => {
                        const player = this.gameState.players.find(p => p.id === playerId);
                        return player ? player.name : '未知玩家';
                    });
                    
                    voteListEl.innerHTML = votedPlayers.map(name => `
                        <div class="text-center text-green-400 font-semibold">
                            ✓ ${name} 已同意
                        </div>
                    `).join('');
                }
            }

            showTurnNotification() {
                const notification = document.createElement('div');
                notification.className = 'turn-notification';
                notification.textContent = '輪到你了！';
                document.body.appendChild(notification);
                
                // 播放提示音效果（使用 Web Audio API 創建簡單的提示音）
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
                
                setTimeout(() => {
                    notification.style.animation = 'turnNotify 0.4s ease-in reverse';
                    setTimeout(() => notification.remove(), 400);
                }, 2000);
            }

            showWinCallout(message, isReason = false) {
                const callout = document.getElementById('win-callout');
                callout.textContent = isReason ? message : `${message} 獲勝！`;
                callout.classList.remove('hidden');
                setTimeout(() => callout.classList.add('hidden'), 3000);
            }
        }

        const game = new MultiplayerUnoGame();
    </script>
</body>
</html>